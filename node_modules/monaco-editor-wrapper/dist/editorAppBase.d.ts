import * as vscode from 'vscode';
import * as monaco from 'monaco-editor';
export type ModelUpdate = {
    languageId: string;
    code?: string;
    codeUri?: string;
    codeOriginal?: string;
    codeOriginalUri?: string;
};
export type EditorAppType = 'extended' | 'classic';
export type EditorAppConfigBase = ModelUpdate & {
    $type: EditorAppType;
    useDiffEditor: boolean;
    domReadOnly?: boolean;
    readOnly?: boolean;
    awaitExtensionReadiness?: Array<() => Promise<void>>;
    overrideAutomaticLayout?: boolean;
    editorOptions?: monaco.editor.IStandaloneEditorConstructionOptions;
    diffEditorOptions?: monaco.editor.IStandaloneDiffEditorConstructionOptions;
};
export declare enum ModelUpdateType {
    NONE = 0,
    CODE = 1,
    MODEL = 2
}
/**
 * This is the base class for both Monaco Ediotor Apps:
 * - EditorAppClassic
 * - EditorAppExtended
 *
 * It provides the generic functionality for both implementations.
 */
export declare abstract class EditorAppBase {
    private id;
    private editor;
    private diffEditor;
    private modelRef;
    private modelOriginalRef;
    constructor(id: string);
    protected buildConfig(userAppConfig: EditorAppConfigBase): EditorAppConfigBase;
    haveEditor(): boolean;
    getEditor(): monaco.editor.IStandaloneCodeEditor | undefined;
    getDiffEditor(): monaco.editor.IStandaloneDiffEditor | undefined;
    createEditors(container: HTMLElement): Promise<void>;
    protected disposeEditor(): void;
    protected disposeDiffEditor(): void;
    getModel(original?: boolean): monaco.editor.ITextModel | undefined;
    updateModel(modelUpdate: ModelUpdate): Promise<void>;
    private updateEditorModel;
    updateDiffModel(modelUpdate: ModelUpdate): Promise<void>;
    private updateDiffEditorModel;
    private updateAppConfig;
    getEditorUri(uriType: 'code' | 'codeOriginal'): vscode.Uri;
    updateLayout(): void;
    awaitReadiness(awaitExtensionReadiness?: Array<() => Promise<void>>): Promise<void | void[]>;
    updateMonacoEditorOptions(options: monaco.editor.IEditorOptions & monaco.editor.IGlobalEditorOptions): void;
    updateUserConfiguration(json?: string): Promise<void>;
    abstract init(): Promise<void>;
    abstract specifyServices(): Promise<monaco.editor.IEditorOverrideServices>;
    abstract getConfig(): EditorAppConfigBase;
    abstract disposeApp(): void;
    abstract isAppConfigDifferent(orgConfig: EditorAppConfigBase, config: EditorAppConfigBase, includeModelData: boolean): boolean;
}
export declare const isCodeUpdateRequired: (config: EditorAppConfigBase, modelUpdate: ModelUpdate) => ModelUpdateType.NONE | ModelUpdateType.CODE;
export declare const isModelUpdateRequired: (config: EditorAppConfigBase, modelUpdate: ModelUpdate) => ModelUpdateType;
/**
 * The check for equality relies on JSON.stringify for instances of type Object.
 * Everything else is directly compared.
 * In this context, the check for equality is sufficient.
 */
export declare const isEqual: (obj1: unknown, obj2: unknown) => boolean;
//# sourceMappingURL=editorAppBase.d.ts.map