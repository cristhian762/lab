import { localizeWithPath } from 'vscode/vscode/vs/nls';
import { isString } from 'vscode/vscode/vs/base/common/types';
import { joinPath, isEqualOrParent } from 'vscode/vscode/vs/base/common/resources';
import { ExtensionsRegistry } from 'vscode/vscode/vs/workbench/services/extensions/common/extensionsRegistry';
import { VS_DARK_THEME, VS_LIGHT_THEME, VS_HC_THEME, VS_HC_LIGHT_THEME, ExtensionData } from 'vscode/vscode/vs/workbench/services/themes/common/workbenchThemeService';
import { Emitter } from 'vscode/vscode/vs/base/common/event';
import { Disposable } from 'vscode/vscode/vs/base/common/lifecycle';
import { Extensions } from 'vscode/vscode/vs/workbench/services/extensionManagement/common/extensionFeatures';
import { MarkdownString } from 'vscode/vscode/vs/base/common/htmlContent';
import { Registry } from 'vscode/vscode/vs/platform/registry/common/platform';
import { SyncDescriptor } from 'vscode/vscode/vs/platform/instantiation/common/descriptors';

function registerColorThemeExtensionPoint() {
    return ExtensionsRegistry.registerExtensionPoint({
        extensionPoint: 'themes',
        jsonSchema: {
            description: ( localizeWithPath(
                'vs/workbench/services/themes/common/themeExtensionPoints',
                'vscode.extension.contributes.themes',
                'Contributes textmate color themes.'
            )),
            type: 'array',
            items: {
                type: 'object',
                defaultSnippets: [{ body: { label: '${1:label}', id: '${2:id}', uiTheme: VS_DARK_THEME, path: './themes/${3:id}.tmTheme.' } }],
                properties: {
                    id: {
                        description: ( localizeWithPath(
                            'vs/workbench/services/themes/common/themeExtensionPoints',
                            'vscode.extension.contributes.themes.id',
                            'Id of the color theme as used in the user settings.'
                        )),
                        type: 'string'
                    },
                    label: {
                        description: ( localizeWithPath(
                            'vs/workbench/services/themes/common/themeExtensionPoints',
                            'vscode.extension.contributes.themes.label',
                            'Label of the color theme as shown in the UI.'
                        )),
                        type: 'string'
                    },
                    uiTheme: {
                        description: ( localizeWithPath(
                            'vs/workbench/services/themes/common/themeExtensionPoints',
                            'vscode.extension.contributes.themes.uiTheme',
                            'Base theme defining the colors around the editor: \'vs\' is the light color theme, \'vs-dark\' is the dark color theme. \'hc-black\' is the dark high contrast theme, \'hc-light\' is the light high contrast theme.'
                        )),
                        enum: [VS_LIGHT_THEME, VS_DARK_THEME, VS_HC_THEME, VS_HC_LIGHT_THEME]
                    },
                    path: {
                        description: ( localizeWithPath(
                            'vs/workbench/services/themes/common/themeExtensionPoints',
                            'vscode.extension.contributes.themes.path',
                            'Path of the tmTheme file. The path is relative to the extension folder and is typically \'./colorthemes/awesome-color-theme.json\'.'
                        )),
                        type: 'string'
                    }
                },
                required: ['path', 'uiTheme']
            }
        }
    });
}
function registerFileIconThemeExtensionPoint() {
    return ExtensionsRegistry.registerExtensionPoint({
        extensionPoint: 'iconThemes',
        jsonSchema: {
            description: ( localizeWithPath(
                'vs/workbench/services/themes/common/themeExtensionPoints',
                'vscode.extension.contributes.iconThemes',
                'Contributes file icon themes.'
            )),
            type: 'array',
            items: {
                type: 'object',
                defaultSnippets: [{ body: { id: '${1:id}', label: '${2:label}', path: './fileicons/${3:id}-icon-theme.json' } }],
                properties: {
                    id: {
                        description: ( localizeWithPath(
                            'vs/workbench/services/themes/common/themeExtensionPoints',
                            'vscode.extension.contributes.iconThemes.id',
                            'Id of the file icon theme as used in the user settings.'
                        )),
                        type: 'string'
                    },
                    label: {
                        description: ( localizeWithPath(
                            'vs/workbench/services/themes/common/themeExtensionPoints',
                            'vscode.extension.contributes.iconThemes.label',
                            'Label of the file icon theme as shown in the UI.'
                        )),
                        type: 'string'
                    },
                    path: {
                        description: ( localizeWithPath(
                            'vs/workbench/services/themes/common/themeExtensionPoints',
                            'vscode.extension.contributes.iconThemes.path',
                            'Path of the file icon theme definition file. The path is relative to the extension folder and is typically \'./fileicons/awesome-icon-theme.json\'.'
                        )),
                        type: 'string'
                    }
                },
                required: ['path', 'id']
            }
        }
    });
}
function registerProductIconThemeExtensionPoint() {
    return ExtensionsRegistry.registerExtensionPoint({
        extensionPoint: 'productIconThemes',
        jsonSchema: {
            description: ( localizeWithPath(
                'vs/workbench/services/themes/common/themeExtensionPoints',
                'vscode.extension.contributes.productIconThemes',
                'Contributes product icon themes.'
            )),
            type: 'array',
            items: {
                type: 'object',
                defaultSnippets: [{ body: { id: '${1:id}', label: '${2:label}', path: './producticons/${3:id}-product-icon-theme.json' } }],
                properties: {
                    id: {
                        description: ( localizeWithPath(
                            'vs/workbench/services/themes/common/themeExtensionPoints',
                            'vscode.extension.contributes.productIconThemes.id',
                            'Id of the product icon theme as used in the user settings.'
                        )),
                        type: 'string'
                    },
                    label: {
                        description: ( localizeWithPath(
                            'vs/workbench/services/themes/common/themeExtensionPoints',
                            'vscode.extension.contributes.productIconThemes.label',
                            'Label of the product icon theme as shown in the UI.'
                        )),
                        type: 'string'
                    },
                    path: {
                        description: ( localizeWithPath(
                            'vs/workbench/services/themes/common/themeExtensionPoints',
                            'vscode.extension.contributes.productIconThemes.path',
                            'Path of the product icon theme definition file. The path is relative to the extension folder and is typically \'./producticons/awesome-product-icon-theme.json\'.'
                        )),
                        type: 'string'
                    }
                },
                required: ['path', 'id']
            }
        }
    });
}
class ThemeDataRenderer extends Disposable {
    constructor() {
        super(...arguments);
        this.type = 'markdown';
    }
    shouldRender(manifest) {
        return !!manifest.contributes?.themes || !!manifest.contributes?.iconThemes || !!manifest.contributes?.productIconThemes;
    }
    render(manifest) {
        const markdown = ( new MarkdownString());
        if (manifest.contributes?.themes) {
            markdown.appendMarkdown(`### ${( localizeWithPath(
                'vs/workbench/services/themes/common/themeExtensionPoints',
                'color themes',
                "Color Themes"
            ))}\n\n`);
            for (const theme of manifest.contributes.themes) {
                markdown.appendMarkdown(`- ${theme.label}\n`);
            }
        }
        if (manifest.contributes?.iconThemes) {
            markdown.appendMarkdown(`### ${( localizeWithPath(
                'vs/workbench/services/themes/common/themeExtensionPoints',
                'file icon themes',
                "File Icon Themes"
            ))}\n\n`);
            for (const theme of manifest.contributes.iconThemes) {
                markdown.appendMarkdown(`- ${theme.label}\n`);
            }
        }
        if (manifest.contributes?.productIconThemes) {
            markdown.appendMarkdown(`### ${( localizeWithPath(
                'vs/workbench/services/themes/common/themeExtensionPoints',
                'product icon themes',
                "Product Icon Themes"
            ))}\n\n`);
            for (const theme of manifest.contributes.productIconThemes) {
                markdown.appendMarkdown(`- ${theme.label}\n`);
            }
        }
        return {
            data: markdown,
            dispose: () => { }
        };
    }
}
( Registry.as(Extensions.ExtensionFeaturesRegistry)).registerExtensionFeature({
    id: 'themes',
    label: ( localizeWithPath(
        'vs/workbench/services/themes/common/themeExtensionPoints',
        'themes',
        "Themes"
    )),
    access: {
        canToggle: false
    },
    renderer: ( new SyncDescriptor(ThemeDataRenderer)),
});
class ThemeRegistry {
    constructor(themesExtPoint, create, idRequired = false, builtInTheme = undefined) {
        this.themesExtPoint = themesExtPoint;
        this.create = create;
        this.idRequired = idRequired;
        this.builtInTheme = builtInTheme;
        this.onDidChangeEmitter = ( new Emitter());
        this.onDidChange = this.onDidChangeEmitter.event;
        this.extensionThemes = [];
        this.initialize();
    }
    initialize() {
        this.themesExtPoint.setHandler((extensions, delta) => {
            const previousIds = {};
            const added = [];
            for (const theme of this.extensionThemes) {
                previousIds[theme.id] = theme;
            }
            this.extensionThemes.length = 0;
            for (const ext of extensions) {
                const extensionData = ExtensionData.fromName(ext.description.publisher, ext.description.name, ext.description.isBuiltin);
                this.onThemes(extensionData, ext.description.extensionLocation, ext.value, this.extensionThemes, ext.collector);
            }
            for (const theme of this.extensionThemes) {
                if (!previousIds[theme.id]) {
                    added.push(theme);
                }
                else {
                    delete previousIds[theme.id];
                }
            }
            const removed = ( Object.values(previousIds));
            this.onDidChangeEmitter.fire({ themes: this.extensionThemes, added, removed });
        });
    }
    onThemes(extensionData, extensionLocation, themeContributions, resultingThemes = [], log) {
        if (!Array.isArray(themeContributions)) {
            log?.error(( localizeWithPath(
                'vs/workbench/services/themes/common/themeExtensionPoints',
                'reqarray',
                "Extension point `{0}` must be an array.",
                this.themesExtPoint.name
            )));
            return resultingThemes;
        }
        themeContributions.forEach(theme => {
            if (!theme.path || !isString(theme.path)) {
                log?.error(( localizeWithPath(
                    'vs/workbench/services/themes/common/themeExtensionPoints',
                    'reqpath',
                    "Expected string in `contributes.{0}.path`. Provided value: {1}",
                    this.themesExtPoint.name,
                    String(theme.path)
                )));
                return;
            }
            if (this.idRequired && (!theme.id || !isString(theme.id))) {
                log?.error(( localizeWithPath(
                    'vs/workbench/services/themes/common/themeExtensionPoints',
                    'reqid',
                    "Expected string in `contributes.{0}.id`. Provided value: {1}",
                    this.themesExtPoint.name,
                    String(theme.id)
                )));
                return;
            }
            const themeLocation = joinPath(extensionLocation, theme.path);
            if (!isEqualOrParent(themeLocation, extensionLocation)) {
                log?.warn(( localizeWithPath(
                    'vs/workbench/services/themes/common/themeExtensionPoints',
                    'invalid.path.1',
                    "Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.",
                    this.themesExtPoint.name,
                    themeLocation.path,
                    extensionLocation.path
                )));
            }
            const themeData = this.create(theme, themeLocation, extensionData);
            resultingThemes.push(themeData);
        });
        return resultingThemes;
    }
    findThemeById(themeId) {
        if (this.builtInTheme && this.builtInTheme.id === themeId) {
            return this.builtInTheme;
        }
        const allThemes = this.getThemes();
        for (const t of allThemes) {
            if (t.id === themeId) {
                return t;
            }
        }
        return undefined;
    }
    findThemeBySettingsId(settingsId, defaultSettingsId) {
        if (this.builtInTheme && this.builtInTheme.settingsId === settingsId) {
            return this.builtInTheme;
        }
        const allThemes = this.getThemes();
        let defaultTheme = undefined;
        for (const t of allThemes) {
            if (t.settingsId === settingsId) {
                return t;
            }
            if (t.settingsId === defaultSettingsId) {
                defaultTheme = t;
            }
        }
        return defaultTheme;
    }
    findThemeByExtensionLocation(extLocation) {
        if (extLocation) {
            return this.getThemes().filter(t => t.location && isEqualOrParent(t.location, extLocation));
        }
        return [];
    }
    getThemes() {
        return this.extensionThemes;
    }
    getMarketplaceThemes(manifest, extensionLocation, extensionData) {
        const themes = manifest?.contributes?.[this.themesExtPoint.name];
        if (Array.isArray(themes)) {
            return this.onThemes(extensionData, extensionLocation, themes);
        }
        return [];
    }
}

export { ThemeRegistry, registerColorThemeExtensionPoint, registerFileIconThemeExtensionPoint, registerProductIconThemeExtensionPoint };
