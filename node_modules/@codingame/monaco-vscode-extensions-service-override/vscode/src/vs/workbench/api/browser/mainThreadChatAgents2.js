import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';
import { Disposable, DisposableMap } from 'vscode/vscode/vs/base/common/lifecycle';
import { revive } from 'vscode/vscode/vs/base/common/marshalling';
import { escapeRegExpCharacters } from 'vscode/vscode/vs/base/common/strings';
import { Range } from 'vscode/vscode/vs/editor/common/core/range';
import { getWordAtText } from 'vscode/vscode/vs/editor/common/core/wordHelper';
import { ILanguageFeaturesService } from 'vscode/vscode/vs/editor/common/services/languageFeatures';
import { IInstantiationService } from 'vscode/vscode/vs/platform/instantiation/common/instantiation';
import { MainContext, ExtHostContext } from 'vscode/vscode/vs/workbench/api/common/extHost.protocol';
import { IChatWidgetService } from 'vscode/vscode/vs/workbench/contrib/chat/browser/chat';
import { ChatInputPart } from 'vscode/vscode/vs/workbench/contrib/chat/browser/chatInputPart';
import { AddDynamicVariableAction } from 'vscode/vscode/vs/workbench/contrib/chat/browser/contrib/chatDynamicVariables';
import { IChatAgentService } from 'vscode/vscode/vs/workbench/contrib/chat/common/chatAgents';
import { ChatRequestAgentPart } from 'vscode/vscode/vs/workbench/contrib/chat/common/chatParserTypes';
import { ChatRequestParser } from 'vscode/vscode/vs/workbench/contrib/chat/common/chatRequestParser';
import { IChatService } from 'vscode/vscode/vs/workbench/contrib/chat/common/chatService';
import { extHostNamedCustomer } from '../../services/extensions/common/extHostCustomers.js';

let MainThreadChatAgents2 = class MainThreadChatAgents2 extends Disposable {
    constructor(extHostContext, _chatAgentService, _chatService, _languageFeaturesService, _chatWidgetService, _instantiationService) {
        super();
        this._chatAgentService = _chatAgentService;
        this._chatService = _chatService;
        this._languageFeaturesService = _languageFeaturesService;
        this._chatWidgetService = _chatWidgetService;
        this._instantiationService = _instantiationService;
        this._agents = this._register(( new DisposableMap()));
        this._agentCompletionProviders = this._register(( new DisposableMap()));
        this._pendingProgress = ( new Map());
        this._proxy = ( extHostContext.getProxy(ExtHostContext.ExtHostChatAgents2));
        this._register(this._chatService.onDidDisposeSession(e => {
            this._proxy.$releaseSession(e.sessionId);
        }));
        this._register(this._chatService.onDidPerformUserAction(e => {
            if (typeof e.agentId === 'string') {
                for (const [handle, agent] of this._agents) {
                    if (agent.name === e.agentId) {
                        if (e.action.kind === 'vote') {
                            this._proxy.$acceptFeedback(handle, e.result ?? {}, e.action.direction);
                        }
                        else {
                            this._proxy.$acceptAction(handle, e.result || {}, e);
                        }
                        break;
                    }
                }
            }
        }));
    }
    $unregisterAgent(handle) {
        this._agents.deleteAndDispose(handle);
    }
    $registerAgent(handle, extension, name, metadata) {
        const lastSlashCommands = ( new WeakMap());
        const d = this._chatAgentService.registerAgent({
            id: name,
            extensionId: extension,
            metadata: revive(metadata),
            invoke: async (request, progress, history, token) => {
                this._pendingProgress.set(request.requestId, progress);
                try {
                    return (await this._proxy.$invokeAgent(handle, request, { history }, token)) ?? {};
                }
                finally {
                    this._pendingProgress.delete(request.requestId);
                }
            },
            provideFollowups: async (request, result, token) => {
                if (!this._agents.get(handle)?.hasFollowups) {
                    return [];
                }
                return this._proxy.$provideFollowups(request, handle, result, token);
            },
            getLastSlashCommands: (model) => {
                return lastSlashCommands.get(model);
            },
            provideSlashCommands: async (model, history, token) => {
                if (!this._agents.get(handle)?.hasSlashCommands) {
                    return [];
                }
                const commands = await this._proxy.$provideSlashCommands(handle, { history }, token);
                if (model) {
                    lastSlashCommands.set(model, commands);
                }
                return commands;
            },
            provideWelcomeMessage: (token) => {
                return this._proxy.$provideWelcomeMessage(handle, token);
            },
            provideSampleQuestions: (token) => {
                return this._proxy.$provideSampleQuestions(handle, token);
            }
        });
        this._agents.set(handle, {
            name,
            dispose: d.dispose,
            hasSlashCommands: metadata.hasSlashCommands,
            hasFollowups: metadata.hasFollowups
        });
    }
    $updateAgent(handle, metadataUpdate) {
        const data = this._agents.get(handle);
        if (!data) {
            throw new Error(`No agent with handle ${handle} registered`);
        }
        data.hasSlashCommands = metadataUpdate.hasSlashCommands;
        data.hasFollowups = metadataUpdate.hasFollowups;
        this._chatAgentService.updateAgent(data.name, revive(metadataUpdate));
    }
    async $handleProgressChunk(requestId, progress) {
        const revivedProgress = revive(progress);
        this._pendingProgress.get(requestId)?.(revivedProgress);
    }
    $registerAgentCompletionsProvider(handle, triggerCharacters) {
        this._agentCompletionProviders.set(handle, this._languageFeaturesService.completionProvider.register({ scheme: ChatInputPart.INPUT_SCHEME, hasAccessToAllModels: true }, {
            _debugDisplayName: 'chatAgentCompletions:' + handle,
            triggerCharacters,
            provideCompletionItems: async (model, position, _context, token) => {
                const widget = this._chatWidgetService.getWidgetByInputUri(model.uri);
                if (!widget || !widget.viewModel) {
                    return;
                }
                const triggerCharsPart = ( triggerCharacters.map(c => escapeRegExpCharacters(c))).join('');
                const wordRegex = ( new RegExp(`[${triggerCharsPart}]\\S*`, 'g'));
                const query = getWordAtText(position.column, wordRegex, model.getLineContent(position.lineNumber), 0)?.word ?? '';
                if (query && !( triggerCharacters.some(c => query.startsWith(c)))) {
                    return;
                }
                const parsedRequest = this._instantiationService.createInstance(ChatRequestParser).parseChatRequest(widget.viewModel.sessionId, model.getValue()).parts;
                const agentPart = parsedRequest.find((part) => part instanceof ChatRequestAgentPart);
                const thisAgentName = this._agents.get(handle)?.name;
                if (agentPart?.agent.id !== thisAgentName) {
                    return;
                }
                const range = computeCompletionRanges(model, position, wordRegex);
                if (!range) {
                    return null;
                }
                const result = await this._proxy.$invokeCompletionProvider(handle, query, token);
                const variableItems = ( result.map(v => {
                    const insertText = v.insertText ?? (typeof v.label === 'string' ? v.label : v.label.label);
                    const rangeAfterInsert = ( new Range(
                        range.insert.startLineNumber,
                        range.insert.startColumn,
                        range.insert.endLineNumber,
                        range.insert.startColumn + insertText.length
                    ));
                    return {
                        label: v.label,
                        range,
                        insertText: insertText + ' ',
                        kind: 18 ,
                        detail: v.detail,
                        documentation: v.documentation,
                        command: { id: AddDynamicVariableAction.ID, title: '', arguments: [{ widget, range: rangeAfterInsert, variableData: revive(v.values) }] }
                    };
                }));
                return {
                    suggestions: variableItems
                };
            }
        }));
    }
    $unregisterAgentCompletionsProvider(handle) {
        this._agentCompletionProviders.deleteAndDispose(handle);
    }
};
MainThreadChatAgents2 = __decorate([
    extHostNamedCustomer(MainContext.MainThreadChatAgents2),
    ( __param(1, IChatAgentService)),
    ( __param(2, IChatService)),
    ( __param(3, ILanguageFeaturesService)),
    ( __param(4, IChatWidgetService)),
    ( __param(5, IInstantiationService))
], MainThreadChatAgents2);
function computeCompletionRanges(model, position, reg) {
    const varWord = getWordAtText(position.column, reg, model.getLineContent(position.lineNumber), 0);
    if (!varWord && model.getWordUntilPosition(position).word) {
        return;
    }
    let insert;
    let replace;
    if (!varWord) {
        insert = replace = Range.fromPositions(position);
    }
    else {
        insert = ( new Range(
            position.lineNumber,
            varWord.startColumn,
            position.lineNumber,
            position.column
        ));
        replace = ( new Range(
            position.lineNumber,
            varWord.startColumn,
            position.lineNumber,
            varWord.endColumn
        ));
    }
    return { insert, replace };
}

export { MainThreadChatAgents2 };
