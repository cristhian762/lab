import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';
import { Event, Emitter } from 'vscode/vscode/vs/base/common/event';
import { DisposableStore, DisposableMap, Disposable, toDisposable } from 'vscode/vscode/vs/base/common/lifecycle';
import { localizeWithPath } from 'vscode/vscode/vs/nls';
import { ILogService } from 'vscode/vscode/vs/platform/log/common/log';
import { Progress } from 'vscode/vscode/vs/platform/progress/common/progress';
import { Registry } from 'vscode/vscode/vs/platform/registry/common/platform';
import { MainContext, ExtHostContext } from 'vscode/vscode/vs/workbench/api/common/extHost.protocol';
import { IChatProviderService } from 'vscode/vscode/vs/workbench/contrib/chat/common/chatProvider';
import { IAuthenticationService, INTERNAL_AUTH_PROVIDER_PREFIX } from 'vscode/vscode/vs/workbench/services/authentication/common/authentication';
import { IExtensionFeaturesManagementService, Extensions } from 'vscode/vscode/vs/workbench/services/extensionManagement/common/extensionFeatures';
import { extHostNamedCustomer } from '../../services/extensions/common/extHostCustomers.js';
import { IExtensionService } from 'vscode/vscode/vs/workbench/services/extensions/common/extensions';

let MainThreadChatProvider = class MainThreadChatProvider {
    constructor(extHostContext, _chatProviderService, _extensionFeaturesManagementService, _logService, _authenticationService, _extensionService) {
        this._chatProviderService = _chatProviderService;
        this._extensionFeaturesManagementService = _extensionFeaturesManagementService;
        this._logService = _logService;
        this._authenticationService = _authenticationService;
        this._extensionService = _extensionService;
        this._store = ( new DisposableStore());
        this._providerRegistrations = ( new DisposableMap());
        this._pendingProgress = ( new Map());
        this._proxy = ( extHostContext.getProxy(ExtHostContext.ExtHostChatProvider));
        this._proxy.$updateLanguageModels({ added: _chatProviderService.getProviders() });
        this._store.add(_chatProviderService.onDidChangeProviders(this._proxy.$updateLanguageModels, this._proxy));
    }
    dispose() {
        this._providerRegistrations.dispose();
        this._store.dispose();
    }
    $registerProvider(handle, identifier, metadata) {
        const dipsosables = ( new DisposableStore());
        dipsosables.add(this._chatProviderService.registerChatResponseProvider(identifier, {
            metadata,
            provideChatResponse: async (messages, from, options, progress, token) => {
                const requestId = (Math.random() * 1e6) | 0;
                this._pendingProgress.set(requestId, progress);
                try {
                    await this._proxy.$provideLanguageModelResponse(handle, requestId, from, messages, options, token);
                }
                finally {
                    this._pendingProgress.delete(requestId);
                }
            }
        }));
        if (metadata.auth) {
            dipsosables.add(this._registerAuthenticationProvider(metadata.extension, metadata.auth));
        }
        dipsosables.add(( Registry.as(Extensions.ExtensionFeaturesRegistry)).registerExtensionFeature({
            id: `lm-${identifier}`,
            label: ( localizeWithPath(
                'vs/workbench/api/browser/mainThreadChatProvider',
                'languageModels',
                "Language Model ({0})",
                `${identifier}`
            )),
            access: {
                canToggle: false,
            },
        }));
        this._providerRegistrations.set(handle, dipsosables);
    }
    async $handleProgressChunk(requestId, chunk) {
        this._pendingProgress.get(requestId)?.report(chunk);
    }
    $unregisterProvider(handle) {
        this._providerRegistrations.deleteAndDispose(handle);
    }
    async $prepareChatAccess(extension, providerId, justification) {
        const activate = this._extensionService.activateByEvent(`onLanguageModelAccess:${providerId}`);
        const metadata = this._chatProviderService.lookupChatResponseProvider(providerId);
        if (metadata) {
            return metadata;
        }
        await Promise.race([
            activate,
            Event.toPromise(Event.filter(this._chatProviderService.onDidChangeProviders, e => Boolean(e.added?.includes(providerId))))
        ]);
        return this._chatProviderService.lookupChatResponseProvider(providerId);
    }
    async $fetchResponse(extension, providerId, requestId, messages, options, token) {
        await this._extensionFeaturesManagementService.getAccess(extension, `lm-${providerId}`);
        this._logService.debug('[CHAT] extension request STARTED', extension.value, requestId);
        const task = this._chatProviderService.fetchChatResponse(providerId, extension, messages, options, ( new Progress(value => {
            this._proxy.$handleResponseFragment(requestId, value);
        })), token);
        task.catch(err => {
            this._logService.error('[CHAT] extension request ERRORED', err, extension.value, requestId);
            throw err;
        }).finally(() => {
            this._logService.debug('[CHAT] extension request DONE', extension.value, requestId);
        });
        return task;
    }
    _registerAuthenticationProvider(extension, auth) {
        const authProviderId = INTERNAL_AUTH_PROVIDER_PREFIX + extension.value;
        if (this._authenticationService.getProviderIds().includes(authProviderId)) {
            return Disposable.None;
        }
        const accountLabel = auth.accountLabel ?? ( localizeWithPath(
            'vs/workbench/api/browser/mainThreadChatProvider',
            'languageModelsAccountId',
            'Language Models'
        ));
        const disposables = ( new DisposableStore());
        this._authenticationService.registerAuthenticationProvider(authProviderId, ( new LanguageModelAccessAuthProvider(authProviderId, auth.providerLabel, accountLabel)));
        disposables.add(toDisposable(() => {
            this._authenticationService.unregisterAuthenticationProvider(authProviderId);
        }));
        disposables.add(this._authenticationService.onDidChangeSessions(async (e) => {
            if (e.providerId === authProviderId) {
                if (e.event.removed?.length) {
                    const allowedExtensions = this._authenticationService.readAllowedExtensions(authProviderId, accountLabel);
                    const extensionsToUpdateAccess = [];
                    for (const allowed of allowedExtensions) {
                        const from = await this._extensionService.getExtension(allowed.id);
                        this._authenticationService.updateAllowedExtension(authProviderId, authProviderId, allowed.id, allowed.name, false);
                        if (from) {
                            extensionsToUpdateAccess.push({
                                from: from.identifier,
                                to: extension,
                                enabled: false
                            });
                        }
                    }
                    this._proxy.$updateModelAccesslist(extensionsToUpdateAccess);
                }
            }
        }));
        disposables.add(this._authenticationService.onDidChangeExtensionSessionAccess(async (e) => {
            const allowedExtensions = this._authenticationService.readAllowedExtensions(authProviderId, accountLabel);
            const accessList = [];
            for (const allowedExtension of allowedExtensions) {
                const from = await this._extensionService.getExtension(allowedExtension.id);
                if (from) {
                    accessList.push({
                        from: from.identifier,
                        to: extension,
                        enabled: allowedExtension.allowed ?? true
                    });
                }
            }
            this._proxy.$updateModelAccesslist(accessList);
        }));
        return disposables;
    }
};
MainThreadChatProvider = __decorate([
    extHostNamedCustomer(MainContext.MainThreadChatProvider),
    ( __param(1, IChatProviderService)),
    ( __param(2, IExtensionFeaturesManagementService)),
    ( __param(3, ILogService)),
    ( __param(4, IAuthenticationService)),
    ( __param(5, IExtensionService))
], MainThreadChatProvider);
class LanguageModelAccessAuthProvider {
    constructor(id, label, _accountLabel) {
        this.id = id;
        this.label = label;
        this._accountLabel = _accountLabel;
        this.supportsMultipleAccounts = false;
        this._onDidChangeSessions = ( new Emitter());
        this.onDidChangeSessions = this._onDidChangeSessions.event;
    }
    async getSessions(scopes) {
        if (scopes === undefined && !this._session) {
            return [];
        }
        if (this._session) {
            return [this._session];
        }
        return [await this.createSession(scopes || [], {})];
    }
    async createSession(scopes, options) {
        this._session = this._createFakeSession(scopes);
        this._onDidChangeSessions.fire({ added: [this._session], changed: [], removed: [] });
        return this._session;
    }
    removeSession(sessionId) {
        if (this._session) {
            this._onDidChangeSessions.fire({ added: [], changed: [], removed: [this._session] });
            this._session = undefined;
        }
        return Promise.resolve();
    }
    _createFakeSession(scopes) {
        return {
            id: 'fake-session',
            account: {
                id: this.id,
                label: this._accountLabel,
            },
            accessToken: 'fake-access-token',
            scopes,
        };
    }
}

export { MainThreadChatProvider };
