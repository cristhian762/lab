import { __decorate } from '../../../../../../external/tslib/tslib.es6.js';
import { append, addDisposableListener, EventType, isAncestor, $ as $$1, addStandardDisposableListener, prepend, asCSSUrl } from '../../../base/browser/dom.js';
import { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';
import { ActionBar } from '../../../base/browser/ui/actionbar/actionbar.js';
import { IconLabel } from '../../../base/browser/ui/iconLabel/iconLabel.js';
import { KeybindingLabel } from '../../../base/browser/ui/keybindingLabel/keybindingLabel.js';
import { range } from '../../../base/common/arrays.js';
import { ThrottledDelayer } from '../../../base/common/async.js';
import { compareAnything } from '../../../base/common/comparers.js';
import { memoize } from '../../../base/common/decorators.js';
import { isCancellationError } from '../../../base/common/errors.js';
import { Emitter, Event } from '../../../base/common/event.js';
import { matchesFuzzyIconAware, parseLabelWithIcons, getCodiconAriaLabel } from '../../../base/common/iconLabels.js';
import { dispose, DisposableStore } from '../../../base/common/lifecycle.js';
import { isMacintosh, OS } from '../../../base/common/platform.js';
import { ltrim } from '../../../base/common/strings.js';
import './media/quickInput.css.js';
import { localizeWithPath } from '../../../nls.js';
import { quickInputButtonToAction } from './quickInputUtils.js';
import { Lazy } from '../../../base/common/lazy.js';
import { URI } from '../../../base/common/uri.js';
import { isDark } from '../../theme/common/theme.js';
const $ = $$1;
class ListElement {
    constructor(mainItem, previous, index, hasCheckbox, fireButtonTriggered, fireSeparatorButtonTriggered, onCheckedEmitter) {
        this._checked = false;
        this._hidden = false;
        this.hasCheckbox = hasCheckbox;
        this.index = index;
        this.fireButtonTriggered = fireButtonTriggered;
        this.fireSeparatorButtonTriggered = fireSeparatorButtonTriggered;
        this._onChecked = onCheckedEmitter;
        this.onChecked = hasCheckbox
            ? ( Event.map(
            Event.filter(this._onChecked.event, e => e.listElement === this),
            e => e.checked
        ))
            : Event.None;
        if (mainItem.type === 'separator') {
            this._separator = mainItem;
        }
        else {
            this.item = mainItem;
            if (previous && previous.type === 'separator' && !previous.buttons) {
                this._separator = previous;
            }
            this.saneDescription = this.item.description;
            this.saneDetail = this.item.detail;
            this._labelHighlights = this.item.highlights?.label;
            this._descriptionHighlights = this.item.highlights?.description;
            this._detailHighlights = this.item.highlights?.detail;
            this.saneTooltip = this.item.tooltip;
        }
        this._init = ( new Lazy(() => {
            const saneLabel = mainItem.label ?? '';
            const saneSortLabel = parseLabelWithIcons(saneLabel).text.trim();
            const saneAriaLabel = mainItem.ariaLabel || ( [saneLabel, this.saneDescription, this.saneDetail]
                .map(s => getCodiconAriaLabel(s)))
                .filter(s => !!s)
                .join(', ');
            return {
                saneLabel,
                saneSortLabel,
                saneAriaLabel
            };
        }));
    }
    get saneLabel() {
        return this._init.value.saneLabel;
    }
    get saneSortLabel() {
        return this._init.value.saneSortLabel;
    }
    get saneAriaLabel() {
        return this._init.value.saneAriaLabel;
    }
    get element() {
        return this._element;
    }
    set element(value) {
        this._element = value;
    }
    get hidden() {
        return this._hidden;
    }
    set hidden(value) {
        this._hidden = value;
    }
    get checked() {
        return this._checked;
    }
    set checked(value) {
        if (value !== this._checked) {
            this._checked = value;
            this._onChecked.fire({ listElement: this, checked: value });
        }
    }
    get separator() {
        return this._separator;
    }
    set separator(value) {
        this._separator = value;
    }
    get labelHighlights() {
        return this._labelHighlights;
    }
    set labelHighlights(value) {
        this._labelHighlights = value;
    }
    get descriptionHighlights() {
        return this._descriptionHighlights;
    }
    set descriptionHighlights(value) {
        this._descriptionHighlights = value;
    }
    get detailHighlights() {
        return this._detailHighlights;
    }
    set detailHighlights(value) {
        this._detailHighlights = value;
    }
}
class ListElementRenderer {
    static { this.ID = 'listelement'; }
    constructor(themeService, hoverDelegate) {
        this.themeService = themeService;
        this.hoverDelegate = hoverDelegate;
    }
    get templateId() {
        return ListElementRenderer.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.toDisposeElement = [];
        data.toDisposeTemplate = [];
        data.entry = append(container, $('.quick-input-list-entry'));
        const label = append(data.entry, $('label.quick-input-list-label'));
        data.toDisposeTemplate.push(addStandardDisposableListener(label, EventType.CLICK, e => {
            if (!data.checkbox.offsetParent) {
                e.preventDefault();
            }
        }));
        data.checkbox = append(label, $('input.quick-input-list-checkbox'));
        data.checkbox.type = 'checkbox';
        data.toDisposeTemplate.push(addStandardDisposableListener(data.checkbox, EventType.CHANGE, e => {
            data.element.checked = data.checkbox.checked;
        }));
        const rows = append(label, $('.quick-input-list-rows'));
        const row1 = append(rows, $('.quick-input-list-row'));
        const row2 = append(rows, $('.quick-input-list-row'));
        data.label = ( new IconLabel(
            row1,
            { supportHighlights: true, supportDescriptionHighlights: true, supportIcons: true, hoverDelegate: this.hoverDelegate }
        ));
        data.toDisposeTemplate.push(data.label);
        data.icon = prepend(data.label.element, $('.quick-input-list-icon'));
        const keybindingContainer = append(row1, $('.quick-input-list-entry-keybinding'));
        data.keybinding = ( new KeybindingLabel(keybindingContainer, OS));
        const detailContainer = append(row2, $('.quick-input-list-label-meta'));
        data.detail = ( new IconLabel(
            detailContainer,
            { supportHighlights: true, supportIcons: true, hoverDelegate: this.hoverDelegate }
        ));
        data.toDisposeTemplate.push(data.detail);
        data.separator = append(data.entry, $('.quick-input-list-separator'));
        data.actionBar = ( new ActionBar(
            data.entry,
            this.hoverDelegate ? { hoverDelegate: this.hoverDelegate } : undefined
        ));
        data.actionBar.domNode.classList.add('quick-input-list-entry-action-bar');
        data.toDisposeTemplate.push(data.actionBar);
        return data;
    }
    renderElement(element, index, data) {
        data.element = element;
        element.element = data.entry ?? undefined;
        const mainItem = element.item ? element.item : element.separator;
        data.checkbox.checked = element.checked;
        data.toDisposeElement.push(element.onChecked(checked => data.checkbox.checked = checked));
        const { labelHighlights, descriptionHighlights, detailHighlights } = element;
        if (element.item?.iconPath) {
            const icon = isDark(this.themeService.getColorTheme().type) ? element.item.iconPath.dark : (element.item.iconPath.light ?? element.item.iconPath.dark);
            const iconUrl = URI.revive(icon);
            data.icon.className = 'quick-input-list-icon';
            data.icon.style.backgroundImage = asCSSUrl(iconUrl);
        }
        else {
            data.icon.style.backgroundImage = '';
            data.icon.className = element.item?.iconClass ? `quick-input-list-icon ${element.item.iconClass}` : '';
        }
        let descriptionTitle;
        if (!element.saneTooltip && element.saneDescription) {
            descriptionTitle = {
                markdown: {
                    value: element.saneDescription,
                    supportThemeIcons: true
                },
                markdownNotSupportedFallback: element.saneDescription
            };
        }
        const options = {
            matches: labelHighlights || [],
            descriptionTitle,
            descriptionMatches: descriptionHighlights || [],
            labelEscapeNewLines: true
        };
        if (mainItem.type !== 'separator') {
            options.extraClasses = mainItem.iconClasses;
            options.italic = mainItem.italic;
            options.strikethrough = mainItem.strikethrough;
            data.entry.classList.remove('quick-input-list-separator-as-item');
        }
        else {
            data.entry.classList.add('quick-input-list-separator-as-item');
        }
        data.label.setLabel(element.saneLabel, element.saneDescription, options);
        data.keybinding.set(mainItem.type === 'separator' ? undefined : mainItem.keybinding);
        if (element.saneDetail) {
            let title;
            if (!element.saneTooltip) {
                title = {
                    markdown: {
                        value: element.saneDetail,
                        supportThemeIcons: true
                    },
                    markdownNotSupportedFallback: element.saneDetail
                };
            }
            data.detail.element.style.display = '';
            data.detail.setLabel(element.saneDetail, undefined, {
                matches: detailHighlights,
                title,
                labelEscapeNewLines: true
            });
        }
        else {
            data.detail.element.style.display = 'none';
        }
        if (element.item && element.separator && element.separator.label) {
            data.separator.textContent = element.separator.label;
            data.separator.style.display = '';
        }
        else {
            data.separator.style.display = 'none';
        }
        data.entry.classList.toggle('quick-input-list-separator-border', !!element.separator);
        const buttons = mainItem.buttons;
        if (buttons && buttons.length) {
            data.actionBar.push(( buttons.map(
                (button, index) => quickInputButtonToAction(button, `id-${index}`, () => mainItem.type !== 'separator'
                    ? element.fireButtonTriggered({ button, item: mainItem })
                    : element.fireSeparatorButtonTriggered({ button, separator: mainItem }))
            )), { icon: true, label: false });
            data.entry.classList.add('has-actions');
        }
        else {
            data.entry.classList.remove('has-actions');
        }
    }
    disposeElement(element, index, data) {
        data.toDisposeElement = dispose(data.toDisposeElement);
        data.actionBar.clear();
    }
    disposeTemplate(data) {
        data.toDisposeElement = dispose(data.toDisposeElement);
        data.toDisposeTemplate = dispose(data.toDisposeTemplate);
    }
}
class ListElementDelegate {
    getHeight(element) {
        if (!element.item) {
            return 24;
        }
        return element.saneDetail ? 44 : 22;
    }
    getTemplateId(element) {
        return ListElementRenderer.ID;
    }
}
var QuickInputListFocus;
( (function(QuickInputListFocus) {
    QuickInputListFocus[QuickInputListFocus["First"] = 1] = "First";
    QuickInputListFocus[QuickInputListFocus["Second"] = 2] = "Second";
    QuickInputListFocus[QuickInputListFocus["Last"] = 3] = "Last";
    QuickInputListFocus[QuickInputListFocus["Next"] = 4] = "Next";
    QuickInputListFocus[QuickInputListFocus["Previous"] = 5] = "Previous";
    QuickInputListFocus[QuickInputListFocus["NextPage"] = 6] = "NextPage";
    QuickInputListFocus[QuickInputListFocus["PreviousPage"] = 7] = "PreviousPage";
})(QuickInputListFocus || (QuickInputListFocus = {})));
class QuickInputList {
    constructor(parent, id, options, themeService) {
        this.parent = parent;
        this.options = options;
        this.inputElements = [];
        this.elements = [];
        this.elementsToIndexes = ( new Map());
        this.matchOnDescription = false;
        this.matchOnDetail = false;
        this.matchOnLabel = true;
        this.matchOnLabelMode = 'fuzzy';
        this.matchOnMeta = true;
        this.sortByLabel = true;
        this._onChangedAllVisibleChecked = ( new Emitter());
        this.onChangedAllVisibleChecked = this._onChangedAllVisibleChecked.event;
        this._onChangedCheckedCount = ( new Emitter());
        this.onChangedCheckedCount = this._onChangedCheckedCount.event;
        this._onChangedVisibleCount = ( new Emitter());
        this.onChangedVisibleCount = this._onChangedVisibleCount.event;
        this._onChangedCheckedElements = ( new Emitter());
        this.onChangedCheckedElements = this._onChangedCheckedElements.event;
        this._onButtonTriggered = ( new Emitter());
        this.onButtonTriggered = this._onButtonTriggered.event;
        this._onSeparatorButtonTriggered = ( new Emitter());
        this.onSeparatorButtonTriggered = this._onSeparatorButtonTriggered.event;
        this._onKeyDown = ( new Emitter());
        this.onKeyDown = this._onKeyDown.event;
        this._onLeave = ( new Emitter());
        this.onLeave = this._onLeave.event;
        this._listElementChecked = ( new Emitter());
        this._fireCheckedEvents = true;
        this.elementDisposables = [];
        this.disposables = [];
        this.id = id;
        this.container = append(this.parent, $('.quick-input-list'));
        const delegate = ( new ListElementDelegate());
        const accessibilityProvider = ( new QuickInputAccessibilityProvider());
        this.list = options.createList('QuickInput', this.container, delegate, [( new ListElementRenderer(themeService, options.hoverDelegate))], {
            identityProvider: {
                getId: element => {
                    return element.item?.id
                        ?? element.item?.label
                        ?? element.separator?.id
                        ?? element.separator?.label
                        ?? '';
                }
            },
            setRowLineHeight: false,
            multipleSelectionSupport: false,
            horizontalScrolling: false,
            accessibilityProvider
        });
        this.list.getHTMLElement().id = id;
        this.disposables.push(this.list);
        this.disposables.push(this.list.onKeyDown(e => {
            const event = ( new StandardKeyboardEvent(e));
            switch (event.keyCode) {
                case 10 :
                    this.toggleCheckbox();
                    break;
                case 31 :
                    if (isMacintosh ? e.metaKey : e.ctrlKey) {
                        this.list.setFocus(range(this.list.length));
                    }
                    break;
                case 16 : {
                    const focus1 = this.list.getFocus();
                    if (focus1.length === 1 && focus1[0] === 0) {
                        this._onLeave.fire();
                    }
                    break;
                }
                case 18 : {
                    const focus2 = this.list.getFocus();
                    if (focus2.length === 1 && focus2[0] === this.list.length - 1) {
                        this._onLeave.fire();
                    }
                    break;
                }
            }
            this._onKeyDown.fire(event);
        }));
        this.disposables.push(this.list.onMouseDown(e => {
            if (e.browserEvent.button !== 2) {
                e.browserEvent.preventDefault();
            }
        }));
        this.disposables.push(addDisposableListener(this.container, EventType.CLICK, e => {
            if (e.x || e.y) {
                this._onLeave.fire();
            }
        }));
        this.disposables.push(this.list.onMouseMiddleClick(e => {
            this._onLeave.fire();
        }));
        this.disposables.push(this.list.onContextMenu(e => {
            if (typeof e.index === 'number') {
                e.browserEvent.preventDefault();
                this.list.setSelection([e.index]);
            }
        }));
        const delayer = ( new ThrottledDelayer(options.hoverDelegate.delay));
        this.disposables.push(this.list.onMouseOver(async (e) => {
            if (e.browserEvent.target instanceof HTMLAnchorElement) {
                delayer.cancel();
                return;
            }
            if (
            !(e.browserEvent.relatedTarget instanceof HTMLAnchorElement) &&
                isAncestor(e.browserEvent.relatedTarget, e.element?.element)) {
                return;
            }
            try {
                await delayer.trigger(async () => {
                    if (e.element) {
                        this.showHover(e.element);
                    }
                });
            }
            catch (e) {
                if (!isCancellationError(e)) {
                    throw e;
                }
            }
        }));
        this.disposables.push(this.list.onMouseOut(e => {
            if (isAncestor(e.browserEvent.relatedTarget, e.element?.element)) {
                return;
            }
            delayer.cancel();
        }));
        this.disposables.push(delayer);
        this.disposables.push(this._listElementChecked.event(_ => this.fireCheckedEvents()));
        this.disposables.push(this._onChangedAllVisibleChecked, this._onChangedCheckedCount, this._onChangedVisibleCount, this._onChangedCheckedElements, this._onButtonTriggered, this._onSeparatorButtonTriggered, this._onLeave, this._onKeyDown);
    }
    get onDidChangeFocus() {
        return ( Event.map(this.list.onDidChangeFocus, e => ( e.elements.map(e => e.item))));
    }
    get onDidChangeSelection() {
        return ( Event.map(this.list.onDidChangeSelection, e => ({ items: ( e.elements.map(e => e.item)), event: e.browserEvent })));
    }
    get scrollTop() {
        return this.list.scrollTop;
    }
    set scrollTop(scrollTop) {
        this.list.scrollTop = scrollTop;
    }
    get ariaLabel() {
        return this.list.getHTMLElement().ariaLabel;
    }
    set ariaLabel(label) {
        this.list.getHTMLElement().ariaLabel = label;
    }
    getAllVisibleChecked() {
        return this.allVisibleChecked(this.elements, false);
    }
    allVisibleChecked(elements, whenNoneVisible = true) {
        for (let i = 0, n = elements.length; i < n; i++) {
            const element = elements[i];
            if (!element.hidden) {
                if (!element.checked) {
                    return false;
                }
                else {
                    whenNoneVisible = true;
                }
            }
        }
        return whenNoneVisible;
    }
    getCheckedCount() {
        let count = 0;
        const elements = this.elements;
        for (let i = 0, n = elements.length; i < n; i++) {
            if (elements[i].checked) {
                count++;
            }
        }
        return count;
    }
    getVisibleCount() {
        let count = 0;
        const elements = this.elements;
        for (let i = 0, n = elements.length; i < n; i++) {
            if (!elements[i].hidden) {
                count++;
            }
        }
        return count;
    }
    setAllVisibleChecked(checked) {
        try {
            this._fireCheckedEvents = false;
            this.elements.forEach(element => {
                if (!element.hidden) {
                    element.checked = checked;
                }
            });
        }
        finally {
            this._fireCheckedEvents = true;
            this.fireCheckedEvents();
        }
    }
    setElements(inputElements) {
        this.elementDisposables = dispose(this.elementDisposables);
        const fireButtonTriggered = (event) => this.fireButtonTriggered(event);
        const fireSeparatorButtonTriggered = (event) => this.fireSeparatorButtonTriggered(event);
        this.inputElements = inputElements;
        const elementsToIndexes = ( new Map());
        const hasCheckbox = this.parent.classList.contains('show-checkboxes');
        this.elements = inputElements.reduce((result, item, index) => {
            const previous = index > 0 ? inputElements[index - 1] : undefined;
            if (item.type === 'separator') {
                if (!item.buttons) {
                    return result;
                }
            }
            const element = ( new ListElement(
                item,
                previous,
                index,
                hasCheckbox,
                fireButtonTriggered,
                fireSeparatorButtonTriggered,
                this._listElementChecked
            ));
            const resultIndex = result.length;
            result.push(element);
            elementsToIndexes.set(element.item ?? element.separator, resultIndex);
            return result;
        }, []);
        this.elementsToIndexes = elementsToIndexes;
        this.list.splice(0, this.list.length);
        this.list.splice(0, this.list.length, this.elements);
        this._onChangedVisibleCount.fire(this.elements.length);
    }
    getElementsCount() {
        return this.inputElements.length;
    }
    getFocusedElements() {
        return ( this.list.getFocusedElements()
            .map(e => e.item));
    }
    setFocusedElements(items) {
        this.list.setFocus(( items
            .filter(item => ( this.elementsToIndexes.has(item)))
            .map(item => this.elementsToIndexes.get(item))));
        if (items.length > 0) {
            const focused = this.list.getFocus()[0];
            if (typeof focused === 'number') {
                this.list.reveal(focused);
            }
        }
    }
    getActiveDescendant() {
        return this.list.getHTMLElement().getAttribute('aria-activedescendant');
    }
    getSelectedElements() {
        return ( this.list.getSelectedElements()
            .map(e => e.item));
    }
    setSelectedElements(items) {
        this.list.setSelection(( items
            .filter(item => ( this.elementsToIndexes.has(item)))
            .map(item => this.elementsToIndexes.get(item))));
    }
    getCheckedElements() {
        return ( this.elements.filter(e => e.checked)
            .map(e => e.item))
            .filter(e => !!e);
    }
    setCheckedElements(items) {
        try {
            this._fireCheckedEvents = false;
            const checked = ( new Set());
            for (const item of items) {
                checked.add(item);
            }
            for (const element of this.elements) {
                element.checked = ( checked.has(element.item));
            }
        }
        finally {
            this._fireCheckedEvents = true;
            this.fireCheckedEvents();
        }
    }
    set enabled(value) {
        this.list.getHTMLElement().style.pointerEvents = value ? '' : 'none';
    }
    focus(what) {
        if (!this.list.length) {
            return;
        }
        if (what === QuickInputListFocus.Second && this.list.length < 2) {
            what = QuickInputListFocus.First;
        }
        switch (what) {
            case QuickInputListFocus.First:
                this.list.scrollTop = 0;
                this.list.focusFirst(undefined, (e) => !!e.item);
                break;
            case QuickInputListFocus.Second:
                this.list.scrollTop = 0;
                this.list.focusNth(1, undefined, (e) => !!e.item);
                break;
            case QuickInputListFocus.Last:
                this.list.scrollTop = this.list.scrollHeight;
                this.list.focusLast(undefined, (e) => !!e.item);
                break;
            case QuickInputListFocus.Next: {
                this.list.focusNext(undefined, true, undefined, (e) => !!e.item);
                const index = this.list.getFocus()[0];
                if (index !== 0 && !this.elements[index - 1].item && this.list.firstVisibleIndex > index - 1) {
                    this.list.reveal(index - 1);
                }
                break;
            }
            case QuickInputListFocus.Previous: {
                this.list.focusPrevious(undefined, true, undefined, (e) => !!e.item);
                const index = this.list.getFocus()[0];
                if (index !== 0 && !this.elements[index - 1].item && this.list.firstVisibleIndex > index - 1) {
                    this.list.reveal(index - 1);
                }
                break;
            }
            case QuickInputListFocus.NextPage:
                this.list.focusNextPage(undefined, (e) => !!e.item);
                break;
            case QuickInputListFocus.PreviousPage:
                this.list.focusPreviousPage(undefined, (e) => !!e.item);
                break;
        }
        const focused = this.list.getFocus()[0];
        if (typeof focused === 'number') {
            this.list.reveal(focused);
        }
    }
    clearFocus() {
        this.list.setFocus([]);
    }
    domFocus() {
        this.list.domFocus();
    }
    showHover(element) {
        if (this._lastHover && !this._lastHover.isDisposed) {
            this.options.hoverDelegate.onDidHideHover?.();
            this._lastHover?.dispose();
        }
        if (!element.element || !element.saneTooltip) {
            return;
        }
        this._lastHover = this.options.hoverDelegate.showHover({
            content: element.saneTooltip,
            target: element.element,
            linkHandler: (url) => {
                this.options.linkOpenerDelegate(url);
            },
            appearance: {
                showPointer: true,
            },
            container: this.container,
            position: {
                hoverPosition: 1
            }
        }, false);
    }
    layout(maxHeight) {
        this.list.getHTMLElement().style.maxHeight = maxHeight ? `${
        Math.floor(maxHeight / 44) * 44
            + 6}px` : '';
        this.list.layout();
    }
    filter(query) {
        if (!(this.sortByLabel || this.matchOnLabel || this.matchOnDescription || this.matchOnDetail)) {
            this.list.layout();
            return false;
        }
        const queryWithWhitespace = query;
        query = query.trim();
        if (!query || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail)) {
            this.elements.forEach(element => {
                element.labelHighlights = undefined;
                element.descriptionHighlights = undefined;
                element.detailHighlights = undefined;
                element.hidden = false;
                const previous = element.index && this.inputElements[element.index - 1];
                if (element.item) {
                    element.separator = previous && previous.type === 'separator' && !previous.buttons ? previous : undefined;
                }
            });
        }
        else {
            let currentSeparator;
            this.elements.forEach(element => {
                let labelHighlights;
                if (this.matchOnLabelMode === 'fuzzy') {
                    labelHighlights = this.matchOnLabel ? matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneLabel)) ?? undefined : undefined;
                }
                else {
                    labelHighlights = this.matchOnLabel ? matchesContiguousIconAware(queryWithWhitespace, parseLabelWithIcons(element.saneLabel)) ?? undefined : undefined;
                }
                const descriptionHighlights = this.matchOnDescription ? matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneDescription || '')) ?? undefined : undefined;
                const detailHighlights = this.matchOnDetail ? matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneDetail || '')) ?? undefined : undefined;
                if (labelHighlights || descriptionHighlights || detailHighlights) {
                    element.labelHighlights = labelHighlights;
                    element.descriptionHighlights = descriptionHighlights;
                    element.detailHighlights = detailHighlights;
                    element.hidden = false;
                }
                else {
                    element.labelHighlights = undefined;
                    element.descriptionHighlights = undefined;
                    element.detailHighlights = undefined;
                    element.hidden = element.item ? !element.item.alwaysShow : true;
                }
                if (element.item) {
                    element.separator = undefined;
                }
                else if (element.separator) {
                    element.hidden = true;
                }
                if (!this.sortByLabel) {
                    const previous = element.index && this.inputElements[element.index - 1];
                    currentSeparator = previous && previous.type === 'separator' ? previous : currentSeparator;
                    if (currentSeparator && !element.hidden) {
                        element.separator = currentSeparator;
                        currentSeparator = undefined;
                    }
                }
            });
        }
        const shownElements = this.elements.filter(element => !element.hidden);
        if (this.sortByLabel && query) {
            const normalizedSearchValue = query.toLowerCase();
            shownElements.sort((a, b) => {
                return compareEntries(a, b, normalizedSearchValue);
            });
        }
        this.elementsToIndexes = shownElements.reduce((map, element, index) => {
            map.set(element.item ?? element.separator, index);
            return map;
        }, ( new Map()));
        this.list.splice(0, this.list.length, shownElements);
        this.list.setFocus([]);
        this.list.layout();
        this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked());
        this._onChangedVisibleCount.fire(shownElements.length);
        return true;
    }
    toggleCheckbox() {
        try {
            this._fireCheckedEvents = false;
            const elements = this.list.getFocusedElements();
            const allChecked = this.allVisibleChecked(elements);
            for (const element of elements) {
                element.checked = !allChecked;
            }
        }
        finally {
            this._fireCheckedEvents = true;
            this.fireCheckedEvents();
        }
    }
    display(display) {
        this.container.style.display = display ? '' : 'none';
    }
    isDisplayed() {
        return this.container.style.display !== 'none';
    }
    dispose() {
        this.elementDisposables = dispose(this.elementDisposables);
        this.disposables = dispose(this.disposables);
    }
    fireCheckedEvents() {
        if (this._fireCheckedEvents) {
            this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked());
            this._onChangedCheckedCount.fire(this.getCheckedCount());
            this._onChangedCheckedElements.fire(this.getCheckedElements());
        }
    }
    fireButtonTriggered(event) {
        this._onButtonTriggered.fire(event);
    }
    fireSeparatorButtonTriggered(event) {
        this._onSeparatorButtonTriggered.fire(event);
    }
    style(styles) {
        this.list.style(styles);
    }
    toggleHover() {
        const element = this.list.getFocusedElements()[0];
        if (!element?.saneTooltip) {
            return;
        }
        if (this._lastHover && !this._lastHover.isDisposed) {
            this._lastHover.dispose();
            return;
        }
        const focused = this.list.getFocusedElements()[0];
        if (!focused) {
            return;
        }
        this.showHover(focused);
        const store = ( new DisposableStore());
        store.add(this.list.onDidChangeFocus(e => {
            if (e.indexes.length) {
                this.showHover(e.elements[0]);
            }
        }));
        if (this._lastHover) {
            store.add(this._lastHover);
        }
        this._toggleHover = store;
        this.elementDisposables.push(this._toggleHover);
    }
}
QuickInputList.__decorator = ( __decorate([
    memoize
], QuickInputList.prototype, "onDidChangeFocus", null));
QuickInputList.__decorator = ( __decorate([
    memoize
], QuickInputList.prototype, "onDidChangeSelection", null));
function matchesContiguousIconAware(query, target) {
    const { text, iconOffsets } = target;
    if (!iconOffsets || iconOffsets.length === 0) {
        return matchesContiguous(query, text);
    }
    const wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');
    const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;
    const matches = matchesContiguous(query, wordToMatchAgainstWithoutIconsTrimmed);
    if (matches) {
        for (const match of matches) {
            const iconOffset = iconOffsets[match.start + leadingWhitespaceOffset]  + leadingWhitespaceOffset ;
            match.start += iconOffset;
            match.end += iconOffset;
        }
    }
    return matches;
}
function matchesContiguous(word, wordToMatchAgainst) {
    const matchIndex = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
    if (matchIndex !== -1) {
        return [{ start: matchIndex, end: matchIndex + word.length }];
    }
    return null;
}
function compareEntries(elementA, elementB, lookFor) {
    const labelHighlightsA = elementA.labelHighlights || [];
    const labelHighlightsB = elementB.labelHighlights || [];
    if (labelHighlightsA.length && !labelHighlightsB.length) {
        return -1;
    }
    if (!labelHighlightsA.length && labelHighlightsB.length) {
        return 1;
    }
    if (labelHighlightsA.length === 0 && labelHighlightsB.length === 0) {
        return 0;
    }
    return compareAnything(elementA.saneSortLabel, elementB.saneSortLabel, lookFor);
}
class QuickInputAccessibilityProvider {
    getWidgetAriaLabel() {
        return ( localizeWithPath(
            'vs/platform/quickinput/browser/quickInputList',
            'quickInput',
            "Quick Input"
        ));
    }
    getAriaLabel(element) {
        return element.separator?.label
            ? `${element.saneAriaLabel}, ${element.separator.label}`
            : element.saneAriaLabel;
    }
    getWidgetRole() {
        return 'listbox';
    }
    getRole(element) {
        return element.hasCheckbox ? 'checkbox' : 'option';
    }
    isChecked(element) {
        if (!element.hasCheckbox) {
            return undefined;
        }
        return {
            value: element.checked,
            onDidChange: element.onChecked
        };
    }
}
export { QuickInputList, QuickInputListFocus };
