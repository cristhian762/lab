import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { WindowIntervalTimer } from '../../../../base/browser/dom.js';
import { coalesceInPlace } from '../../../../base/common/arrays.js';
import { Emitter, Event } from '../../../../base/common/event.js';
import { Lazy } from '../../../../base/common/lazy.js';
import { DisposableStore } from '../../../../base/common/lifecycle.js';
import { themeColorFromId } from '../../../../base/common/themables.js';
import { StableEditorScrollState } from '../../../../editor/browser/stableEditorScroll.js';
import { RenderOptions, LineSource, renderLines } from '../../../../editor/browser/widget/diffEditor/components/diffEditorViewZones/renderLines.js';
import { EditOperation } from '../../../../editor/common/core/editOperation.js';
import { LineRange } from '../../../../editor/common/core/lineRange.js';
import { Range } from '../../../../editor/common/core/range.js';
import { OverviewRulerLane } from '../../../../editor/common/model.js';
import { ModelDecorationOptions } from '../../../../editor/common/model/textModel.js';
import { IEditorWorkerService } from '../../../../editor/common/services/editorWorker.js';
import { InlineDecoration } from '../../../../editor/common/viewModel.js';
import { localizeWithPath } from '../../../../nls.js';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';
import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
import { Progress } from '../../../../platform/progress/common/progress.js';
import { countWords } from '../../chat/common/chatWordCounter.js';
import { InlineChatFileCreatePreviewWidget, InlineChatLivePreviewWidget } from './inlineChatLivePreviewWidget.js';
import { ReplyResponse } from './inlineChatSession.js';
import { CTX_INLINE_CHAT_DOCUMENT_CHANGED, CTX_INLINE_CHAT_CHANGE_HAS_DIFF, CTX_INLINE_CHAT_CHANGE_SHOWS_DIFF, overviewRulerInlineChatDiffInserted } from '../common/inlineChat.js';
import { assertType } from '../../../../base/common/types.js';
import { IModelService } from '../../../../editor/common/services/model.js';
import { asProgressiveEdit, performAsyncTextEdit } from './utils.js';
import { IAccessibilityService } from '../../../../platform/accessibility/common/accessibility.js';
import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';
class EditModeStrategy {
    static { this._decoBlock = ModelDecorationOptions.register({
        description: 'inline-chat',
        showIfCollapsed: false,
        isWholeLine: true,
        className: 'inline-chat-block-selection',
    }); }
    constructor(_session, _editor, _zone) {
        this._session = _session;
        this._editor = _editor;
        this._zone = _zone;
        this._store = ( new DisposableStore());
        this._onDidAccept = this._store.add(( new Emitter()));
        this._onDidDiscard = this._store.add(( new Emitter()));
        this._editCount = 0;
        this.onDidAccept = this._onDidAccept.event;
        this.onDidDiscard = this._onDidDiscard.event;
    }
    dispose() {
        this._store.dispose();
    }
    cancel() {
        return this._session.hunkData.discardAll();
    }
    async acceptHunk() {
        this._onDidAccept.fire();
    }
    async discardHunk() {
        this._onDidDiscard.fire();
    }
    async _makeChanges(edits, obs, opts, progress) {
        if (++this._editCount === 1) {
            this._editor.pushUndoStop();
        }
        if (opts) {
            const durationInSec = opts.duration / 1000;
            for (const edit of edits) {
                const wordCount = countWords(edit.text ?? '');
                const speed = wordCount / durationInSec;
                const asyncEdit = asProgressiveEdit(( new WindowIntervalTimer(this._zone.domNode)), edit, speed, opts.token);
                await performAsyncTextEdit(this._session.textModelN, asyncEdit, progress, obs);
            }
        }
        else {
            obs.start();
            this._session.textModelN.pushEditOperations(null, edits, (undoEdits) => {
                progress?.report(undoEdits);
                return null;
            });
            obs.stop();
        }
    }
    getWholeRangeDecoration() {
        const ranges = [this._session.wholeRange.value];
        const newDecorations = ( ranges.map(
            range => range.isEmpty() ? undefined : ({ range, options: EditModeStrategy._decoBlock })
        ));
        coalesceInPlace(newDecorations);
        return newDecorations;
    }
}
let PreviewStrategy = class PreviewStrategy extends EditModeStrategy {
    constructor(session, editor, zone, modelService, contextKeyService) {
        super(session, editor, zone);
        this._ctxDocumentChanged = CTX_INLINE_CHAT_DOCUMENT_CHANGED.bindTo(contextKeyService);
        const baseModel = modelService.getModel(session.targetUri);
        Event.debounce(baseModel.onDidChangeContent.bind(baseModel), () => { }, 350)(_ => {
            if (!baseModel.isDisposed() && !session.textModel0.isDisposed()) {
                this._ctxDocumentChanged.set(session.hasChangedText);
            }
        }, undefined, this._store);
    }
    dispose() {
        this._ctxDocumentChanged.reset();
        super.dispose();
    }
    async apply() {
        const textModel = this._editor.getModel();
        if (textModel?.equalsTextBuffer(this._session.textModel0.getTextBuffer())) {
            this._session.hunkData.getInfo().forEach(item => item.acceptChanges());
            const newText = this._session.textModel0.getValue();
            const range = textModel.getFullModelRange();
            textModel.pushStackElement();
            textModel.pushEditOperations(null, [EditOperation.replace(range, newText)], () => null);
            textModel.pushStackElement();
        }
        if (this._session.lastExchange?.response instanceof ReplyResponse) {
            const { untitledTextModel } = this._session.lastExchange.response;
            if (untitledTextModel && !untitledTextModel.isDisposed() && untitledTextModel.isDirty()) {
                await untitledTextModel.save({ reason: 1  });
            }
        }
    }
    async makeChanges(edits, obs) {
        return this._makeChanges(edits, obs, undefined, undefined);
    }
    async makeProgressiveChanges(edits, obs, opts) {
        await this._makeChanges(edits, obs, opts, ( new Progress(() => {
            this._zone.widget.showEditsPreview(this._session.hunkData, this._session.textModel0, this._session.textModelN);
        })));
    }
    async undoChanges(altVersionId) {
        const { textModelN } = this._session;
        await undoModelUntil(textModelN, altVersionId);
    }
    async renderChanges(response) {
        if (response.allLocalEdits.length > 0) {
            this._zone.widget.showEditsPreview(this._session.hunkData, this._session.textModel0, this._session.textModelN);
        }
        else {
            this._zone.widget.hideEditsPreview();
        }
        if (response.untitledTextModel) {
            this._zone.widget.showCreatePreview(response.untitledTextModel);
        }
        else {
            this._zone.widget.hideCreatePreview();
        }
    }
    hasFocus() {
        return this._zone.widget.hasFocus();
    }
};
PreviewStrategy = ( __decorate([
    ( __param(3, IModelService)),
    ( __param(4, IContextKeyService))
], PreviewStrategy));
let LivePreviewStrategy = class LivePreviewStrategy extends EditModeStrategy {
    constructor(session, editor, zone, _instaService) {
        super(session, editor, zone);
        this._instaService = _instaService;
        this._diffZonePool = [];
        this._previewZone = ( new Lazy(
            () => _instaService.createInstance(InlineChatFileCreatePreviewWidget, editor)
        ));
    }
    dispose() {
        for (const zone of this._diffZonePool) {
            zone.hide();
            zone.dispose();
        }
        this._previewZone.rawValue?.hide();
        this._previewZone.rawValue?.dispose();
        super.dispose();
    }
    async apply() {
        if (this._editCount > 0) {
            this._editor.pushUndoStop();
        }
        if (!(this._session.lastExchange?.response instanceof ReplyResponse)) {
            return;
        }
        const { untitledTextModel } = this._session.lastExchange.response;
        if (untitledTextModel && !untitledTextModel.isDisposed() && untitledTextModel.isDirty()) {
            await untitledTextModel.save({ reason: 1  });
        }
    }
    async undoChanges(altVersionId) {
        const { textModelN } = this._session;
        await undoModelUntil(textModelN, altVersionId);
        this._updateDiffZones();
    }
    async makeChanges(edits, obs) {
        return this._makeChanges(edits, obs, undefined, undefined);
    }
    async makeProgressiveChanges(edits, obs, opts) {
        await this._makeChanges(edits, obs, opts, ( new Progress(() => {
            this._updateDiffZones();
        })));
    }
    async renderChanges(response) {
        if (response.untitledTextModel && !response.untitledTextModel.isDisposed()) {
            this._previewZone.value.showCreation(this._session.wholeRange.value.getStartPosition().delta(-1), response.untitledTextModel);
        }
        else {
            this._previewZone.rawValue?.hide();
        }
        return this._updateDiffZones();
    }
    _updateSummaryMessage(hunkCount) {
        let message;
        if (hunkCount === 0) {
            message = ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies',
                'change.0',
                "Nothing changed"
            ));
        }
        else if (hunkCount === 1) {
            message = ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies',
                'change.1',
                "1 change"
            ));
        }
        else {
            message = ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies',
                'lines.NM',
                "{0} changes",
                hunkCount
            ));
        }
        this._zone.widget.updateStatus(message);
    }
    _updateDiffZones() {
        const { hunkData } = this._session;
        const hunks = hunkData.getInfo().filter(hunk => hunk.getState() === 0 );
        if (hunks.length === 0) {
            for (const zone of this._diffZonePool) {
                zone.hide();
            }
            if (hunkData.getInfo().find(hunk => hunk.getState() === 1 )) {
                this._onDidAccept.fire();
            }
            else {
                this._onDidDiscard.fire();
            }
            return;
        }
        this._updateSummaryMessage(hunks.length);
        const handleDiff = () => this._updateDiffZones();
        let nearest;
        while (hunks.length > this._diffZonePool.length) {
            this._diffZonePool.push(this._instaService.createInstance(InlineChatLivePreviewWidget, this._editor, this._session, {}, this._diffZonePool.length === 0 ? handleDiff : undefined));
        }
        for (let i = 0; i < hunks.length; i++) {
            const hunk = hunks[i];
            this._diffZonePool[i].showForChanges(hunk);
            const modifiedRange = hunk.getRangesN()[0];
            const zoneLineNumber = this._zone.position.lineNumber;
            const distance = zoneLineNumber <= modifiedRange.startLineNumber
                ? modifiedRange.startLineNumber - zoneLineNumber
                : zoneLineNumber - modifiedRange.endLineNumber;
            if (!nearest || nearest.distance > distance) {
                nearest = {
                    position: modifiedRange.getStartPosition().delta(-1),
                    distance,
                    accept: () => {
                        hunk.acceptChanges();
                        handleDiff();
                    },
                    discard: () => {
                        hunk.discardChanges();
                        handleDiff();
                    }
                };
            }
        }
        for (let i = hunks.length; i < this._diffZonePool.length; i++) {
            this._diffZonePool[i].hide();
        }
        this.acceptHunk = async () => nearest?.accept();
        this.discardHunk = async () => nearest?.discard();
        if (nearest) {
            this._zone.updatePositionAndHeight(nearest.position);
            this._editor.revealPositionInCenterIfOutsideViewport(nearest.position);
        }
        return nearest?.position;
    }
    hasFocus() {
        return this._zone.widget.hasFocus()
            || Boolean(this._previewZone.rawValue?.hasFocus())
            || ( this._diffZonePool.some(zone => zone.isVisible && zone.hasFocus()));
    }
};
LivePreviewStrategy = ( __decorate([
    ( __param(3, IInstantiationService))
], LivePreviewStrategy));
let LiveStrategy = class LiveStrategy extends EditModeStrategy {
    constructor(session, editor, zone, contextKeyService, _editorWorkerService, _accessibilityService, _configService, _instaService) {
        super(session, editor, zone);
        this._editorWorkerService = _editorWorkerService;
        this._accessibilityService = _accessibilityService;
        this._configService = _configService;
        this._instaService = _instaService;
        this._decoInsertedText = ModelDecorationOptions.register({
            description: 'inline-modified-line',
            className: 'inline-chat-inserted-range-linehighlight',
            isWholeLine: true,
            overviewRuler: {
                position: OverviewRulerLane.Full,
                color: themeColorFromId(overviewRulerInlineChatDiffInserted),
            }
        });
        this._decoInsertedTextRange = ModelDecorationOptions.register({
            description: 'inline-chat-inserted-range-linehighlight',
            className: 'inline-chat-inserted-range',
            stickiness: 1 ,
        });
        this.acceptHunk = () => super.acceptHunk();
        this.discardHunk = () => super.discardHunk();
        this._hunkDisplayData = ( new Map());
        this._ctxCurrentChangeHasDiff = CTX_INLINE_CHAT_CHANGE_HAS_DIFF.bindTo(contextKeyService);
        this._ctxCurrentChangeShowsDiff = CTX_INLINE_CHAT_CHANGE_SHOWS_DIFF.bindTo(contextKeyService);
        this._progressiveEditingDecorations = this._editor.createDecorationsCollection();
        this._previewZone = ( new Lazy(
            () => _instaService.createInstance(InlineChatFileCreatePreviewWidget, editor)
        ));
    }
    dispose() {
        this._resetDiff();
        this._previewZone.rawValue?.dispose();
        super.dispose();
    }
    _resetDiff() {
        this._ctxCurrentChangeHasDiff.reset();
        this._ctxCurrentChangeShowsDiff.reset();
        this._zone.widget.updateStatus('');
        this._progressiveEditingDecorations.clear();
        for (const data of ( this._hunkDisplayData.values())) {
            data.remove();
        }
    }
    async apply() {
        this._resetDiff();
        if (this._editCount > 0) {
            this._editor.pushUndoStop();
        }
        if (!(this._session.lastExchange?.response instanceof ReplyResponse)) {
            return;
        }
        const { untitledTextModel } = this._session.lastExchange.response;
        if (untitledTextModel && !untitledTextModel.isDisposed() && untitledTextModel.isDirty()) {
            await untitledTextModel.save({ reason: 1  });
        }
    }
    cancel() {
        this._resetDiff();
        return super.cancel();
    }
    async undoChanges(altVersionId) {
        const { textModelN } = this._session;
        await undoModelUntil(textModelN, altVersionId);
    }
    async makeChanges(edits, obs) {
        return this._makeChanges(edits, obs, undefined, undefined);
    }
    async makeProgressiveChanges(edits, obs, opts) {
        const progress = ( new Progress(edits => {
            const newLines = ( new Set());
            for (const edit of edits) {
                LineRange.fromRange(edit.range).forEach(line => newLines.add(line));
            }
            const existingRanges = ( this._progressiveEditingDecorations.getRanges().map(LineRange.fromRange));
            for (const existingRange of existingRanges) {
                existingRange.forEach(line => newLines.delete(line));
            }
            const newDecorations = [];
            for (const line of newLines) {
                newDecorations.push({ range: ( new Range(line, 1, line, Number.MAX_VALUE)), options: this._decoInsertedText });
            }
            this._progressiveEditingDecorations.append(newDecorations);
        }));
        return this._makeChanges(edits, obs, opts, progress);
    }
    async renderChanges(response) {
        if (response.untitledTextModel && !response.untitledTextModel.isDisposed()) {
            this._previewZone.value.showCreation(this._session.wholeRange.value.getStartPosition().delta(-1), response.untitledTextModel);
        }
        else {
            this._previewZone.rawValue?.hide();
        }
        this._progressiveEditingDecorations.clear();
        const renderHunks = () => {
            let widgetData;
            changeDecorationsAndViewZones(this._editor, (decorationsAccessor, viewZoneAccessor) => {
                const keysNow = ( new Set(( this._hunkDisplayData.keys())));
                widgetData = undefined;
                for (const hunkData of this._session.hunkData.getInfo()) {
                    keysNow.delete(hunkData);
                    const hunkRanges = hunkData.getRangesN();
                    let data = this._hunkDisplayData.get(hunkData);
                    if (!data) {
                        const decorationIds = [];
                        for (let i = 0; i < hunkRanges.length; i++) {
                            decorationIds.push(decorationsAccessor.addDecoration(hunkRanges[i], i === 0
                                ? this._decoInsertedText
                                : this._decoInsertedTextRange));
                        }
                        const acceptHunk = () => {
                            hunkData.acceptChanges();
                            renderHunks();
                        };
                        const discardHunk = () => {
                            hunkData.discardChanges();
                            renderHunks();
                        };
                        const mightContainNonBasicASCII = this._session.textModel0.mightContainNonBasicASCII();
                        const mightContainRTL = this._session.textModel0.mightContainRTL();
                        const renderOptions = RenderOptions.fromEditor(this._editor);
                        const originalRange = hunkData.getRanges0()[0];
                        const source = ( new LineSource(
                            LineRange.fromRangeInclusive(originalRange).mapToLineArray(l => this._session.textModel0.tokenization.getLineTokens(l)),
                            [],
                            mightContainNonBasicASCII,
                            mightContainRTL
                        ));
                        const domNode = document.createElement('div');
                        domNode.className = 'inline-chat-original-zone2';
                        const result = renderLines(source, renderOptions, [( new InlineDecoration(( new Range(originalRange.startLineNumber, 1, originalRange.startLineNumber, 1)), '', 0 ))], domNode);
                        const viewZoneData = {
                            afterLineNumber: -1,
                            heightInLines: result.heightInLines,
                            domNode,
                        };
                        const toggleDiff = () => {
                            const scrollState = StableEditorScrollState.capture(this._editor);
                            changeDecorationsAndViewZones(this._editor, (_decorationsAccessor, viewZoneAccessor) => {
                                assertType(data);
                                if (!data.viewZoneId) {
                                    const [hunkRange] = hunkData.getRangesN();
                                    viewZoneData.afterLineNumber = hunkRange.startLineNumber - 1;
                                    data.viewZoneId = viewZoneAccessor.addZone(viewZoneData);
                                }
                                else {
                                    viewZoneAccessor.removeZone(data.viewZoneId);
                                    data.viewZoneId = undefined;
                                }
                            });
                            this._ctxCurrentChangeShowsDiff.set(typeof data?.viewZoneId === 'number');
                            scrollState.restore(this._editor);
                        };
                        const remove = () => {
                            changeDecorationsAndViewZones(this._editor, (decorationsAccessor, viewZoneAccessor) => {
                                assertType(data);
                                for (const decorationId of data.decorationIds) {
                                    decorationsAccessor.removeDecoration(decorationId);
                                }
                                if (data.viewZoneId) {
                                    viewZoneAccessor.removeZone(data.viewZoneId);
                                }
                                data.decorationIds = [];
                                data.viewZoneId = undefined;
                            });
                        };
                        const move = (next) => {
                            assertType(widgetData);
                            const candidates = [];
                            for (const item of this._session.hunkData.getInfo()) {
                                if (item.getState() === 0 ) {
                                    candidates.push(item.getRangesN()[0].getStartPosition().delta(-1));
                                }
                            }
                            if (candidates.length < 2) {
                                return;
                            }
                            for (let i = 0; i < candidates.length; i++) {
                                if (candidates[i].equals(widgetData.position)) {
                                    let newPos;
                                    if (next) {
                                        newPos = candidates[(i + 1) % candidates.length];
                                    }
                                    else {
                                        newPos = candidates[(i + candidates.length - 1) % candidates.length];
                                    }
                                    this._zone.updatePositionAndHeight(newPos);
                                    renderHunks();
                                    break;
                                }
                            }
                        };
                        const zoneLineNumber = this._zone.position.lineNumber;
                        const myDistance = zoneLineNumber <= hunkRanges[0].startLineNumber
                            ? hunkRanges[0].startLineNumber - zoneLineNumber
                            : zoneLineNumber - hunkRanges[0].endLineNumber;
                        data = {
                            hunk: hunkData,
                            decorationIds,
                            viewZoneId: '',
                            viewZone: viewZoneData,
                            distance: myDistance,
                            position: hunkRanges[0].getStartPosition().delta(-1),
                            acceptHunk,
                            discardHunk,
                            toggleDiff: !hunkData.isInsertion() ? toggleDiff : undefined,
                            remove,
                            move,
                        };
                        this._hunkDisplayData.set(hunkData, data);
                    }
                    else if (hunkData.getState() !== 0 ) {
                        data.remove();
                    }
                    else {
                        const zoneLineNumber = this._zone.position.lineNumber;
                        const modifiedRangeNow = hunkRanges[0];
                        data.position = modifiedRangeNow.getStartPosition().delta(-1);
                        data.distance = zoneLineNumber <= modifiedRangeNow.startLineNumber
                            ? modifiedRangeNow.startLineNumber - zoneLineNumber
                            : zoneLineNumber - modifiedRangeNow.endLineNumber;
                    }
                    if (hunkData.getState() === 0  && (!widgetData || data.distance < widgetData.distance)) {
                        widgetData = data;
                    }
                }
                for (const key of keysNow) {
                    const data = this._hunkDisplayData.get(key);
                    if (data) {
                        this._hunkDisplayData.delete(key);
                        data.remove();
                    }
                }
            });
            if (widgetData) {
                this._zone.updatePositionAndHeight(widgetData.position);
                this._editor.revealPositionInCenterIfOutsideViewport(widgetData.position);
                const remainingHunks = this._session.hunkData.pending;
                this._updateSummaryMessage(remainingHunks);
                const mode = this._configService.getValue("inlineChat.accessibleDiffView" );
                if (mode === 'on' || mode === 'auto' && this._accessibilityService.isScreenReaderOptimized()) {
                    this._zone.widget.showAccessibleHunk(this._session, widgetData.hunk);
                }
                this._ctxCurrentChangeHasDiff.set(Boolean(widgetData.toggleDiff));
                this.toggleDiff = widgetData.toggleDiff;
                this.acceptHunk = async () => widgetData.acceptHunk();
                this.discardHunk = async () => widgetData.discardHunk();
                this.move = next => widgetData.move(next);
            }
            else if (this._hunkDisplayData.size > 0) {
                let oneAccepted = false;
                for (const hunkData of this._session.hunkData.getInfo()) {
                    if (hunkData.getState() === 1 ) {
                        oneAccepted = true;
                        break;
                    }
                }
                if (oneAccepted) {
                    this._onDidAccept.fire();
                }
                else {
                    this._onDidDiscard.fire();
                }
            }
            return widgetData;
        };
        return renderHunks()?.position;
    }
    _updateSummaryMessage(hunkCount) {
        let message;
        if (hunkCount === 0) {
            message = ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies',
                'change.0',
                "Nothing changed"
            ));
        }
        else if (hunkCount === 1) {
            message = ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies',
                'change.1',
                "1 change"
            ));
        }
        else {
            message = ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies',
                'lines.NM',
                "{0} changes",
                hunkCount
            ));
        }
        this._zone.widget.updateStatus(message);
    }
    hasFocus() {
        return this._zone.widget.hasFocus();
    }
    getWholeRangeDecoration() {
        return [];
    }
};
LiveStrategy = ( __decorate([
    ( __param(3, IContextKeyService)),
    ( __param(4, IEditorWorkerService)),
    ( __param(5, IAccessibilityService)),
    ( __param(6, IConfigurationService)),
    ( __param(7, IInstantiationService))
], LiveStrategy));
async function undoModelUntil(model, targetAltVersion) {
    while (targetAltVersion < model.getAlternativeVersionId() && model.canUndo()) {
        await model.undo();
    }
}
function changeDecorationsAndViewZones(editor, callback) {
    editor.changeDecorations(decorationsAccessor => {
        editor.changeViewZones(viewZoneAccessor => {
            callback(decorationsAccessor, viewZoneAccessor);
        });
    });
}
export { EditModeStrategy, LivePreviewStrategy, LiveStrategy, PreviewStrategy };
