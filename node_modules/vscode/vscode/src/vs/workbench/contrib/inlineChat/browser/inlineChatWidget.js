import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { h, addDisposableListener, getTotalWidth, Dimension, getTotalHeight, reset, getActiveElement } from '../../../../base/browser/dom.js';
import { renderFormattedText } from '../../../../base/browser/formattedTextRenderer.js';
import { status } from '../../../../base/browser/ui/aria/aria.js';
import { renderLabelWithIcons } from '../../../../base/browser/ui/iconLabel/iconLabels.js';
import { ProgressBar } from '../../../../base/browser/ui/progressbar/progressbar.js';
import { MicrotaskEmitter, Event, Emitter } from '../../../../base/common/event.js';
import { MarkdownString } from '../../../../base/common/htmlContent.js';
import { Lazy } from '../../../../base/common/lazy.js';
import { DisposableStore, MutableDisposable, toDisposable } from '../../../../base/common/lifecycle.js';
import { assertType } from '../../../../base/common/types.js';
import { URI } from '../../../../base/common/uri.js';
import './inlineChat.css.js';
import { EditorExtensionsRegistry } from '../../../../editor/browser/editorExtensions.js';
import { AccessibleDiffViewer } from '../../../../editor/browser/widget/diffEditor/components/accessibleDiffViewer.js';
import { EmbeddedCodeEditorWidget, EmbeddedDiffEditorWidget } from '../../../../editor/browser/widget/embeddedCodeEditorWidget.js';
import { LineRange } from '../../../../editor/common/core/lineRange.js';
import { Range } from '../../../../editor/common/core/range.js';
import { DetailedLineRangeMapping, RangeMapping } from '../../../../editor/common/diff/rangeMapping.js';
import { ILanguageFeaturesService } from '../../../../editor/common/services/languageFeatures.js';
import { IModelService } from '../../../../editor/common/services/model.js';
import { ITextModelService } from '../../../../editor/common/services/resolverService.js';
import { SnippetController2 } from '../../../../editor/contrib/snippet/browser/snippetController2.js';
import { SuggestController } from '../../../../editor/contrib/suggest/browser/suggestController.js';
import { ZoneWidget } from '../../../../editor/contrib/zoneWidget/browser/zoneWidget.js';
import { localizeWithPath } from '../../../../nls.js';
import { IAccessibilityService } from '../../../../platform/accessibility/common/accessibility.js';
import { MenuWorkbenchButtonBar } from '../../../../platform/actions/browser/buttonbar.js';
import { MenuWorkbenchToolBar } from '../../../../platform/actions/browser/toolbar.js';
import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';
import { FileKind } from '../../../../platform/files/common/files.js';
import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
import { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';
import { ILogService } from '../../../../platform/log/common/log.js';
import { editorForeground, inputBackground, editorBackground } from '../../../../platform/theme/common/colorRegistry.js';
import { ResourceLabel } from '../../../browser/labels.js';
import { DEFAULT_FONT_FAMILY } from '../../../browser/style.js';
import { IAccessibleViewService } from '../../accessibility/browser/accessibleView.js';
import { ChatFollowups } from '../../chat/browser/chatFollowups.js';
import { ChatListItemRenderer } from '../../chat/browser/chatListRenderer.js';
import { ChatEditorOptions } from '../../chat/browser/chatOptions.js';
import { SlashCommandContentWidget } from '../../chat/browser/chatSlashCommandContentWidget.js';
import { IChatAgentService } from '../../chat/common/chatAgents.js';
import { ChatModel, ChatResponseModel } from '../../chat/common/chatModel.js';
import { ChatResponseViewModel } from '../../chat/common/chatViewModel.js';
import { ExpansionState } from './inlineChatSession.js';
import { invertLineRange, asRange } from './utils.js';
import { CTX_INLINE_CHAT_MESSAGE_CROP_STATE, CTX_INLINE_CHAT_EMPTY, CTX_INLINE_CHAT_INNER_CURSOR_FIRST, CTX_INLINE_CHAT_INNER_CURSOR_LAST, CTX_INLINE_CHAT_INNER_CURSOR_START, CTX_INLINE_CHAT_INNER_CURSOR_END, CTX_INLINE_CHAT_FOCUSED, CTX_INLINE_CHAT_RESPONSE_FOCUSED, MENU_INLINE_CHAT_WIDGET_MARKDOWN_MESSAGE, ACTION_REGENERATE_RESPONSE, ACTION_VIEW_IN_CHAT, ACTION_ACCEPT_CHANGES, CTX_INLINE_CHAT_VISIBLE, CTX_INLINE_CHAT_OUTER_CURSOR_POSITION, MENU_INLINE_CHAT_INPUT, MENU_INLINE_CHAT_WIDGET, MENU_INLINE_CHAT_WIDGET_STATUS, MENU_INLINE_CHAT_WIDGET_FEEDBACK } from '../common/inlineChat.js';
import { observableValue } from '../../../../base/common/observableInternal/base.js';
import { derived } from '../../../../base/common/observableInternal/derived.js';
import { constObservable } from '../../../../base/common/observableInternal/utils.js';
var InlineChatWidget_1, HunkAccessibleDiffViewer_1;
const defaultAriaLabel = ( localizeWithPath(
    'vs/workbench/contrib/inlineChat/browser/inlineChatWidget',
    'aria-label',
    "Inline Chat Input"
));
const _inputEditorOptions = {
    padding: { top: 2, bottom: 2 },
    overviewRulerLanes: 0,
    glyphMargin: false,
    lineNumbers: 'off',
    folding: false,
    hideCursorInOverviewRuler: true,
    selectOnLineNumbers: false,
    selectionHighlight: false,
    scrollbar: {
        useShadows: false,
        vertical: 'hidden',
        horizontal: 'auto',
        alwaysConsumeMouseWheel: false
    },
    lineDecorationsWidth: 0,
    overviewRulerBorder: false,
    scrollBeyondLastLine: false,
    renderLineHighlight: 'none',
    fixedOverflowWidgets: true,
    dragAndDrop: false,
    revealHorizontalRightPadding: 5,
    minimap: { enabled: false },
    guides: { indentation: false },
    rulers: [],
    cursorWidth: 1,
    cursorStyle: 'line',
    cursorBlinking: 'blink',
    wrappingStrategy: 'advanced',
    wrappingIndent: 'none',
    renderWhitespace: 'none',
    dropIntoEditor: { enabled: true },
    quickSuggestions: false,
    suggest: {
        showIcons: false,
        showSnippets: false,
        showWords: true,
        showStatusBar: false,
    },
    wordWrap: 'on',
    ariaLabel: defaultAriaLabel,
    fontFamily: DEFAULT_FONT_FAMILY,
    fontSize: 13,
    lineHeight: 20
};
const _previewEditorEditorOptions = {
    scrollbar: { useShadows: false, alwaysConsumeMouseWheel: false, ignoreHorizontalScrollbarInContentHeight: true, },
    renderMarginRevertIcon: false,
    diffCodeLens: false,
    scrollBeyondLastLine: false,
    stickyScroll: { enabled: false },
    originalAriaLabel: ( localizeWithPath(
        'vs/workbench/contrib/inlineChat/browser/inlineChatWidget',
        'original',
        'Original'
    )),
    modifiedAriaLabel: ( localizeWithPath(
        'vs/workbench/contrib/inlineChat/browser/inlineChatWidget',
        'modified',
        'Modified'
    )),
    diffAlgorithm: 'advanced',
    readOnly: true,
    isInEmbeddedEditor: true
};
let InlineChatWidget = class InlineChatWidget {
    static { InlineChatWidget_1 = this; }
    static { this._modelPool = 1; }
    constructor(parentEditor, _options, _modelService, _contextKeyService, _languageFeaturesService, _keybindingService, _instantiationService, _accessibilityService, _configurationService, _accessibleViewService, _logService, _textModelResolverService, _chatAgentService) {
        this.parentEditor = parentEditor;
        this._modelService = _modelService;
        this._contextKeyService = _contextKeyService;
        this._languageFeaturesService = _languageFeaturesService;
        this._keybindingService = _keybindingService;
        this._instantiationService = _instantiationService;
        this._accessibilityService = _accessibilityService;
        this._configurationService = _configurationService;
        this._accessibleViewService = _accessibleViewService;
        this._logService = _logService;
        this._textModelResolverService = _textModelResolverService;
        this._chatAgentService = _chatAgentService;
        this._elements = h('div.inline-chat@root', [
            h('div.body', [
                h('div.content@content', [
                    h('div.input@input', [
                        h('div.editor-placeholder@placeholder'),
                        h('div.editor-container@editor'),
                    ]),
                    h('div.toolbar@editorToolbar'),
                ]),
                h('div.widget-toolbar@widgetToolbar')
            ]),
            h('div.progress@progress'),
            h('div.detectedIntent.hidden@detectedIntent'),
            h('div.previewDiff.hidden@previewDiff'),
            h('div.previewCreateTitle.show-file-icons@previewCreateTitle'),
            h('div.previewCreate.hidden@previewCreate'),
            h('div.chatMessage.hidden@chatMessage', [
                h('div.chatMessageContent@chatMessageContent'),
                h('div.messageActions@messageActions')
            ]),
            h('div.followUps.hidden@followUps'),
            h('div.accessibleViewer@accessibleViewer'),
            h('div.status@status', [
                h('div.label.info.hidden@infoLabel'),
                h('div.actions.hidden@statusToolbar'),
                h('div.label.status.hidden@statusLabel'),
                h('div.actions.hidden@feedbackToolbar'),
            ]),
        ]);
        this._store = ( new DisposableStore());
        this._slashCommands = this._store.add(( new DisposableStore()));
        this._previewDiffModel = this._store.add(( new MutableDisposable()));
        this._accessibleViewer = this._store.add(( new MutableDisposable()));
        this._previewCreateDispoable = this._store.add(( new MutableDisposable()));
        this._onDidChangeHeight = this._store.add(( new MicrotaskEmitter()));
        this.onDidChangeHeight = Event.filter(this._onDidChangeHeight.event, _ => !this._isLayouting);
        this._onDidChangeLayout = this._store.add(( new MicrotaskEmitter()));
        this._onDidChangeInput = this._store.add(( new Emitter()));
        this.onDidChangeInput = this._onDidChangeInput.event;
        this._onRequestWithoutIntentDetection = this._store.add(( new Emitter()));
        this.onRequestWithoutIntentDetection = this._onRequestWithoutIntentDetection.event;
        this._isLayouting = false;
        this._expansionState = ExpansionState.NOT_CROPPED;
        this._slashCommandDetails = [];
        this._chatMessageDisposables = this._store.add(( new DisposableStore()));
        this._followUpDisposables = this._store.add(( new DisposableStore()));
        this._slashCommandUsedDisposables = this._store.add(( new DisposableStore()));
        const codeEditorWidgetOptions = {
            isSimpleWidget: true,
            contributions: EditorExtensionsRegistry.getSomeEditorContributions([
                SnippetController2.ID,
                SuggestController.ID
            ])
        };
        this._inputEditor = this._instantiationService.createInstance(EmbeddedCodeEditorWidget, this._elements.editor, _inputEditorOptions, codeEditorWidgetOptions, this.parentEditor);
        this._updateAriaLabel();
        this._store.add(this._inputEditor);
        this._store.add(this._inputEditor.onDidChangeModelContent(() => this._onDidChangeInput.fire(this)));
        this._store.add(this._inputEditor.onDidLayoutChange(() => this._onDidChangeHeight.fire()));
        this._store.add(this._inputEditor.onDidContentSizeChange(() => this._onDidChangeHeight.fire()));
        this._store.add(addDisposableListener(this._elements.chatMessageContent, 'focus', () => this._ctxResponseFocused.set(true)));
        this._store.add(addDisposableListener(this._elements.chatMessageContent, 'blur', () => this._ctxResponseFocused.reset()));
        this._store.add(this._configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration("accessibility.verbosity.inlineChat" )) {
                this._updateAriaLabel();
            }
        }));
        const uri = ( URI.from(
            { scheme: 'vscode', authority: 'inline-chat', path: `/inline-chat/model${InlineChatWidget_1._modelPool++}.txt` }
        ));
        this._inputModel = this._store.add(this._modelService.getModel(uri) ?? this._modelService.createModel('', null, uri));
        this._inputEditor.setModel(this._inputModel);
        this._editorOptions = this._store.add(_instantiationService.createInstance(ChatEditorOptions, undefined, editorForeground, inputBackground, editorBackground));
        this._ctxMessageCropState = CTX_INLINE_CHAT_MESSAGE_CROP_STATE.bindTo(this._contextKeyService);
        this._ctxInputEmpty = CTX_INLINE_CHAT_EMPTY.bindTo(this._contextKeyService);
        this._ctxInnerCursorFirst = CTX_INLINE_CHAT_INNER_CURSOR_FIRST.bindTo(this._contextKeyService);
        this._ctxInnerCursorLast = CTX_INLINE_CHAT_INNER_CURSOR_LAST.bindTo(this._contextKeyService);
        this._ctxInnerCursorStart = CTX_INLINE_CHAT_INNER_CURSOR_START.bindTo(this._contextKeyService);
        this._ctxInnerCursorEnd = CTX_INLINE_CHAT_INNER_CURSOR_END.bindTo(this._contextKeyService);
        this._ctxInputEditorFocused = CTX_INLINE_CHAT_FOCUSED.bindTo(this._contextKeyService);
        this._ctxResponseFocused = CTX_INLINE_CHAT_RESPONSE_FOCUSED.bindTo(this._contextKeyService);
        const updateInnerCursorFirstLast = () => {
            const selection = this._inputEditor.getSelection();
            const fullRange = this._inputModel.getFullModelRange();
            let onFirst = false;
            let onLast = false;
            if (selection.isEmpty()) {
                const selectionTop = this._inputEditor.getTopForPosition(selection.startLineNumber, selection.startColumn);
                const firstViewLineTop = this._inputEditor.getTopForPosition(fullRange.startLineNumber, fullRange.startColumn);
                const lastViewLineTop = this._inputEditor.getTopForPosition(fullRange.endLineNumber, fullRange.endColumn);
                if (selectionTop === firstViewLineTop) {
                    onFirst = true;
                }
                if (selectionTop === lastViewLineTop) {
                    onLast = true;
                }
            }
            this._ctxInnerCursorFirst.set(onFirst);
            this._ctxInnerCursorLast.set(onLast);
            this._ctxInnerCursorStart.set(fullRange.getStartPosition().equals(selection.getStartPosition()));
            this._ctxInnerCursorEnd.set(fullRange.getEndPosition().equals(selection.getEndPosition()));
        };
        this._store.add(this._inputEditor.onDidChangeCursorPosition(updateInnerCursorFirstLast));
        updateInnerCursorFirstLast();
        const updateFocused = () => {
            const hasFocus = this._inputEditor.hasWidgetFocus();
            this._ctxInputEditorFocused.set(hasFocus);
            this._elements.content.classList.toggle('synthetic-focus', hasFocus);
            this.readPlaceholder();
        };
        this._store.add(this._inputEditor.onDidFocusEditorWidget(updateFocused));
        this._store.add(this._inputEditor.onDidBlurEditorWidget(updateFocused));
        this._store.add(toDisposable(() => {
            this._ctxInnerCursorFirst.reset();
            this._ctxInnerCursorLast.reset();
            this._ctxInputEditorFocused.reset();
        }));
        updateFocused();
        this._elements.placeholder.style.fontSize = `${this._inputEditor.getOption(52 )}px`;
        this._elements.placeholder.style.lineHeight = `${this._inputEditor.getOption(67 )}px`;
        this._store.add(addDisposableListener(this._elements.placeholder, 'click', () => this._inputEditor.focus()));
        const currentContentHeight = 0;
        const togglePlaceholder = () => {
            const hasText = this._inputModel.getValueLength() > 0;
            this._elements.placeholder.classList.toggle('hidden', hasText);
            this._ctxInputEmpty.set(!hasText);
            this.readPlaceholder();
            const contentHeight = this._inputEditor.getContentHeight();
            if (contentHeight !== currentContentHeight && this._lastDim) {
                this._lastDim = this._lastDim.with(undefined, contentHeight);
                this._inputEditor.layout(this._lastDim);
                this._onDidChangeHeight.fire();
            }
        };
        this._store.add(this._inputModel.onDidChangeContent(togglePlaceholder));
        togglePlaceholder();
        this._slashCommandContentWidget = ( new SlashCommandContentWidget(this._inputEditor));
        this._store.add(this._slashCommandContentWidget);
        this._store.add(this._instantiationService.createInstance(MenuWorkbenchToolBar, this._elements.editorToolbar, _options.menuId, {
            telemetrySource: 'interactiveEditorWidget-toolbar',
            toolbarOptions: { primaryGroup: 'main' },
            hiddenItemStrategy: 0
        }));
        this._progressBar = ( new ProgressBar(this._elements.progress));
        this._store.add(this._progressBar);
        this._store.add(this._instantiationService.createInstance(MenuWorkbenchToolBar, this._elements.widgetToolbar, _options.widgetMenuId, {
            telemetrySource: 'interactiveEditorWidget-toolbar',
            toolbarOptions: { primaryGroup: 'main' }
        }));
        const workbenchMenubarOptions = {
            telemetrySource: 'interactiveEditorWidget-toolbar',
            buttonConfigProvider: action => {
                if (action.id === ACTION_REGENERATE_RESPONSE) {
                    return { showIcon: true, showLabel: false, isSecondary: true };
                }
                else if (action.id === ACTION_VIEW_IN_CHAT || action.id === ACTION_ACCEPT_CHANGES) {
                    return { isSecondary: false };
                }
                else {
                    return { isSecondary: true };
                }
            }
        };
        const statusButtonBar = this._instantiationService.createInstance(MenuWorkbenchButtonBar, this._elements.statusToolbar, _options.statusMenuId, workbenchMenubarOptions);
        this._store.add(statusButtonBar.onDidChange(() => this._onDidChangeHeight.fire()));
        this._store.add(statusButtonBar);
        const workbenchToolbarOptions = {
            hiddenItemStrategy: -1 ,
            toolbarOptions: {
                primaryGroup: () => true,
                useSeparatorsInPrimaryActions: true
            }
        };
        const feedbackToolbar = this._instantiationService.createInstance(MenuWorkbenchToolBar, this._elements.feedbackToolbar, _options.feedbackMenuId, { ...workbenchToolbarOptions, hiddenItemStrategy: 0  });
        this._store.add(feedbackToolbar.onDidChangeMenuItems(() => this._onDidChangeHeight.fire()));
        this._store.add(feedbackToolbar);
        this._previewDiffEditor = ( new Lazy(
            () => this._store.add(_instantiationService.createInstance(EmbeddedDiffEditorWidget, this._elements.previewDiff, {
                useInlineViewWhenSpaceIsLimited: false,
                ..._previewEditorEditorOptions,
                onlyShowAccessibleDiffViewer: this._accessibilityService.isScreenReaderOptimized(),
            }, { modifiedEditor: codeEditorWidgetOptions, originalEditor: codeEditorWidgetOptions }, parentEditor))
        ));
        this._previewCreateTitle = this._store.add(_instantiationService.createInstance(ResourceLabel, this._elements.previewCreateTitle, { supportIcons: true }));
        this._previewCreateEditor = ( new Lazy(
            () => this._store.add(_instantiationService.createInstance(EmbeddedCodeEditorWidget, this._elements.previewCreate, _previewEditorEditorOptions, codeEditorWidgetOptions, parentEditor))
        ));
        this._elements.chatMessageContent.tabIndex = 0;
        this._elements.chatMessageContent.ariaLabel = this._accessibleViewService.getOpenAriaHint("accessibility.verbosity.inlineChat" );
        this._elements.followUps.tabIndex = 0;
        this._elements.followUps.ariaLabel = this._accessibleViewService.getOpenAriaHint("accessibility.verbosity.inlineChat" );
        this._elements.statusLabel.tabIndex = 0;
        const markdownMessageToolbar = this._instantiationService.createInstance(MenuWorkbenchToolBar, this._elements.messageActions, MENU_INLINE_CHAT_WIDGET_MARKDOWN_MESSAGE, workbenchToolbarOptions);
        this._store.add(markdownMessageToolbar.onDidChangeMenuItems(() => this._onDidChangeHeight.fire()));
        this._store.add(markdownMessageToolbar);
        this._store.add(this._configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration("accessibility.verbosity.inlineChat" )) {
                this._elements.chatMessageContent.ariaLabel = this._accessibleViewService.getOpenAriaHint("accessibility.verbosity.inlineChat" );
                this._elements.followUps.ariaLabel = this._accessibleViewService.getOpenAriaHint("accessibility.verbosity.inlineChat" );
            }
        }));
    }
    _updateAriaLabel() {
        if (!this._accessibilityService.isScreenReaderOptimized()) {
            return;
        }
        let label = defaultAriaLabel;
        if (this._configurationService.getValue("accessibility.verbosity.inlineChat" )) {
            const kbLabel = this._keybindingService.lookupKeybinding("editor.action.accessibilityHelp" )?.getLabel();
            label = kbLabel ? ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatWidget',
                'inlineChat.accessibilityHelp',
                "Inline Chat Input, Use {0} for Inline Chat Accessibility Help.",
                kbLabel
            )) : ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatWidget',
                'inlineChat.accessibilityHelpNoKb',
                "Inline Chat Input, Run the Inline Chat Accessibility Help command for more information."
            ));
        }
        _inputEditorOptions.ariaLabel = label;
        this._inputEditor.updateOptions({ ariaLabel: label });
    }
    dispose() {
        this._store.dispose();
        this._ctxInputEmpty.reset();
        this._ctxMessageCropState.reset();
    }
    get domNode() {
        return this._elements.root;
    }
    layout(_dim) {
        this._isLayouting = true;
        try {
            if (this._accessibleViewer.value) {
                this._accessibleViewer.value.width = _dim.width - 12;
            }
            const widgetToolbarWidth = getTotalWidth(this._elements.widgetToolbar);
            const editorToolbarWidth = getTotalWidth(this._elements.editorToolbar) + 8 ;
            const innerEditorWidth = _dim.width - editorToolbarWidth - widgetToolbarWidth;
            const dim = ( new Dimension(innerEditorWidth, _dim.height));
            if (!this._lastDim || !Dimension.equals(this._lastDim, dim)) {
                this._lastDim = dim;
                this._inputEditor.layout(( new Dimension(innerEditorWidth, this._inputEditor.getContentHeight())));
                this._elements.placeholder.style.width = `${innerEditorWidth }px`;
                if (this._previewDiffEditor.hasValue) {
                    const previewDiffDim = ( new Dimension(
                        _dim.width - 12,
                        Math.min(300, Math.max(0, this._previewDiffEditor.value.getContentHeight()))
                    ));
                    this._elements.previewDiff.style.width = `${previewDiffDim.width}px`;
                    this._elements.previewDiff.style.height = `${previewDiffDim.height}px`;
                    this._previewDiffEditor.value.layout(previewDiffDim);
                }
                if (this._previewCreateEditor.hasValue) {
                    const previewCreateDim = ( new Dimension(
                        dim.width,
                        Math.min(300, Math.max(0, this._previewCreateEditor.value.getContentHeight()))
                    ));
                    this._previewCreateEditor.value.layout(previewCreateDim);
                    this._elements.previewCreate.style.height = `${previewCreateDim.height}px`;
                }
                const lineHeight = this.parentEditor.getOption(67 );
                const editorHeight = this.parentEditor.getLayoutInfo().height;
                const editorHeightInLines = Math.floor(editorHeight / lineHeight);
                this._elements.root.style.setProperty('--vscode-inline-chat-cropped', String(Math.floor(editorHeightInLines / 5)));
                this._elements.root.style.setProperty('--vscode-inline-chat-expanded', String(Math.floor(editorHeightInLines / 3)));
                this._onDidChangeLayout.fire();
            }
        }
        finally {
            this._isLayouting = false;
        }
    }
    getHeight() {
        const base = getTotalHeight(this._elements.progress) + getTotalHeight(this._elements.status);
        const editorHeight = this._inputEditor.getContentHeight() + 12 ;
        const detectedIntentHeight = getTotalHeight(this._elements.detectedIntent);
        const followUpsHeight = getTotalHeight(this._elements.followUps);
        const chatResponseHeight = getTotalHeight(this._elements.chatMessage);
        const previewDiffHeight = this._previewDiffEditor.hasValue && this._previewDiffEditor.value.getModel() ? 12 + Math.min(300, Math.max(0, this._previewDiffEditor.value.getContentHeight())) : 0;
        const previewCreateTitleHeight = getTotalHeight(this._elements.previewCreateTitle);
        const previewCreateHeight = this._previewCreateEditor.hasValue && this._previewCreateEditor.value.getModel() ? 18 + Math.min(300, Math.max(0, this._previewCreateEditor.value.getContentHeight())) : 0;
        const accessibleViewHeight = this._accessibleViewer.value?.height ?? 0;
        return base + editorHeight + detectedIntentHeight + followUpsHeight + chatResponseHeight + previewDiffHeight + previewCreateTitleHeight + previewCreateHeight + accessibleViewHeight + 18  + 8 ;
    }
    updateProgress(show) {
        if (show) {
            this._progressBar.show();
            this._progressBar.infinite();
        }
        else {
            this._progressBar.stop();
            this._progressBar.hide();
        }
    }
    get value() {
        return this._inputModel.getValue();
    }
    set value(value) {
        this._inputModel.setValue(value);
        this._inputEditor.setPosition(this._inputModel.getFullModelRange().getEndPosition());
    }
    selectAll(includeSlashCommand = true) {
        let selection = this._inputModel.getFullModelRange();
        if (!includeSlashCommand) {
            const firstLine = this._inputModel.getLineContent(1);
            const slashCommand = this._slashCommandDetails.find(c => firstLine.startsWith(`/${c.command} `));
            selection = slashCommand ? ( new Range(
                1,
                slashCommand.command.length + 3,
                selection.endLineNumber,
                selection.endColumn
            )) : selection;
        }
        this._inputEditor.setSelection(selection);
    }
    set placeholder(value) {
        this._elements.placeholder.innerText = value;
    }
    readPlaceholder() {
        const slashCommand = this._slashCommandDetails.find(c => `${c.command} ` === this._inputModel.getValue().substring(1));
        const hasText = this._inputModel.getValueLength() > 0;
        if (!hasText) {
            status(this._elements.placeholder.innerText);
        }
        else if (slashCommand) {
            status(slashCommand.detail);
        }
    }
    updateToolbar(show) {
        this._elements.statusToolbar.classList.toggle('hidden', !show);
        this._elements.feedbackToolbar.classList.toggle('hidden', !show);
        this._elements.status.classList.toggle('actions', show);
        this._elements.infoLabel.classList.toggle('hidden', show);
        this._onDidChangeHeight.fire();
    }
    get expansionState() {
        return this._expansionState;
    }
    set preferredExpansionState(expansionState) {
        this._preferredExpansionState = expansionState;
    }
    get responseContent() {
        return this._chatMessage?.value;
    }
    updateChatMessage(message, isIncomplete) {
        let expansionState;
        this._chatMessageDisposables.clear();
        this._chatMessage = message ? ( new MarkdownString(message.message.value)) : undefined;
        const hasMessage = message?.message.value;
        this._elements.chatMessage.classList.toggle('hidden', !hasMessage);
        reset(this._elements.chatMessageContent);
        let resultingAppender;
        if (!hasMessage) {
            this._ctxMessageCropState.reset();
            expansionState = ExpansionState.NOT_CROPPED;
        }
        else {
            const sessionModel = this._chatMessageDisposables.add(( new ChatModel(message.providerId, undefined, this._logService, this._chatAgentService)));
            const responseModel = this._chatMessageDisposables.add(( new ChatResponseModel(
                message.message,
                sessionModel,
                undefined,
                undefined,
                message.requestId,
                !isIncomplete,
                false,
                undefined
            )));
            const viewModel = this._chatMessageDisposables.add(( new ChatResponseViewModel(responseModel, this._logService)));
            const renderOptions = { renderStyle: 'compact', noHeader: true, noPadding: true };
            const chatRendererDelegate = { getListLength() { return 1; } };
            const renderer = this._chatMessageDisposables.add(this._instantiationService.createInstance(ChatListItemRenderer, this._editorOptions, renderOptions, chatRendererDelegate, undefined));
            renderer.layout(this._elements.chatMessageContent.clientWidth - 4);
            this._chatMessageDisposables.add(this._onDidChangeLayout.event(() => {
                renderer.layout(this._elements.chatMessageContent.clientWidth - 4);
            }));
            const template = renderer.renderTemplate(this._elements.chatMessageContent);
            this._chatMessageDisposables.add(template.elementDisposables);
            this._chatMessageDisposables.add(template.templateDisposables);
            renderer.renderChatTreeItem(viewModel, 0, template);
            this._chatMessageDisposables.add(renderer.onDidChangeItemHeight(() => this._onDidChangeHeight.fire()));
            if (this._preferredExpansionState) {
                expansionState = this._preferredExpansionState;
                this._preferredExpansionState = undefined;
            }
            else {
                this._updateLineClamp(ExpansionState.CROPPED);
                expansionState = template.value.scrollHeight > template.value.clientHeight ? ExpansionState.CROPPED : ExpansionState.NOT_CROPPED;
            }
            this._ctxMessageCropState.set(expansionState);
            this._updateLineClamp(expansionState);
            resultingAppender = isIncomplete ? {
                cancel: () => responseModel.cancel(),
                complete: () => responseModel.complete(),
                appendContent: (fragment) => {
                    responseModel.updateContent({ kind: 'markdownContent', content: ( new MarkdownString(fragment)) });
                    this._chatMessage?.appendMarkdown(fragment);
                }
            } : undefined;
        }
        this._expansionState = expansionState;
        this._onDidChangeHeight.fire();
        return resultingAppender;
    }
    updateFollowUps(items, onFollowup) {
        this._followUpDisposables.clear();
        this._elements.followUps.classList.toggle('hidden', !items || items.length === 0);
        reset(this._elements.followUps);
        if (items && items.length > 0 && onFollowup) {
            this._followUpDisposables.add(this._instantiationService.createInstance(ChatFollowups, this._elements.followUps, items, undefined, onFollowup));
        }
        this._onDidChangeHeight.fire();
    }
    updateChatMessageExpansionState(expansionState) {
        this._ctxMessageCropState.set(expansionState);
        const heightBefore = this._elements.chatMessageContent.scrollHeight;
        this._updateLineClamp(expansionState);
        const heightAfter = this._elements.chatMessageContent.scrollHeight;
        if (heightBefore === heightAfter) {
            this._ctxMessageCropState.set(ExpansionState.NOT_CROPPED);
        }
        this._onDidChangeHeight.fire();
    }
    _updateLineClamp(expansionState) {
        this._elements.chatMessageContent.setAttribute('state', expansionState);
    }
    updateSlashCommandUsed(command) {
        const details = this._slashCommandDetails.find(candidate => candidate.command === command);
        if (!details) {
            return;
        }
        this._elements.detectedIntent.classList.toggle('hidden', false);
        this._slashCommandUsedDisposables.clear();
        const label = ( localizeWithPath(
            'vs/workbench/contrib/inlineChat/browser/inlineChatWidget',
            'slashCommandUsed',
            "Using {0} to generate response ([[re-run without]])",
            `\`\`/${details.command}\`\``
        ));
        const usingSlashCommandText = renderFormattedText(label, {
            inline: true,
            renderCodeSegments: true,
            className: 'slash-command-pill',
            actionHandler: {
                callback: (content) => {
                    if (content !== '0') {
                        return;
                    }
                    this._elements.detectedIntent.classList.toggle('hidden', true);
                    this._onRequestWithoutIntentDetection.fire();
                },
                disposables: this._slashCommandUsedDisposables,
            }
        });
        reset(this._elements.detectedIntent, usingSlashCommandText);
        this._onDidChangeHeight.fire();
    }
    updateInfo(message) {
        this._elements.infoLabel.classList.toggle('hidden', !message);
        const renderedMessage = renderLabelWithIcons(message);
        reset(this._elements.infoLabel, ...renderedMessage);
        this._onDidChangeHeight.fire();
    }
    updateStatus(message, ops = {}) {
        const isTempMessage = typeof ops.resetAfter === 'number';
        if (isTempMessage && !this._elements.statusLabel.dataset['state']) {
            const statusLabel = this._elements.statusLabel.innerText;
            const classes = Array.from(( this._elements.statusLabel.classList.values()));
            setTimeout(() => {
                this.updateStatus(statusLabel, { classes, keepMessage: true });
            }, ops.resetAfter);
        }
        reset(this._elements.statusLabel, message);
        this._elements.statusLabel.className = `label status ${(ops.classes ?? []).join(' ')}`;
        this._elements.statusLabel.classList.toggle('hidden', !message);
        if (isTempMessage) {
            this._elements.statusLabel.dataset['state'] = 'temp';
        }
        else {
            delete this._elements.statusLabel.dataset['state'];
        }
        this._onDidChangeHeight.fire();
    }
    reset() {
        this._ctxInputEmpty.reset();
        this._ctxInnerCursorFirst.reset();
        this._ctxInnerCursorLast.reset();
        this._ctxInputEditorFocused.reset();
        this.value = '';
        this.updateChatMessage(undefined);
        this.updateFollowUps(undefined);
        reset(this._elements.statusLabel);
        this._elements.detectedIntent.classList.toggle('hidden', true);
        this._elements.statusLabel.classList.toggle('hidden', true);
        this._elements.statusToolbar.classList.add('hidden');
        this._elements.feedbackToolbar.classList.add('hidden');
        this.updateInfo('');
        this.hideCreatePreview();
        this.hideEditsPreview();
        this._accessibleViewer.clear();
        this._elements.accessibleViewer.classList.toggle('hidden', true);
        this._onDidChangeHeight.fire();
    }
    focus() {
        this._inputEditor.focus();
    }
    hasFocus() {
        return this.domNode.contains(getActiveElement());
    }
    showEditsPreview(hunks, textModel0, textModelN) {
        if (hunks.size === 0) {
            this.hideEditsPreview();
            return;
        }
        this._elements.previewDiff.classList.remove('hidden');
        this._previewDiffEditor.value.setModel({ original: textModel0, modified: textModelN });
        let originalLineRange;
        let modifiedLineRange;
        for (const item of hunks.getInfo()) {
            const [first0] = item.getRanges0();
            const [firstN] = item.getRangesN();
            originalLineRange = !originalLineRange ? LineRange.fromRangeInclusive(first0) : originalLineRange.join(LineRange.fromRangeInclusive(first0));
            modifiedLineRange = !modifiedLineRange ? LineRange.fromRangeInclusive(firstN) : modifiedLineRange.join(LineRange.fromRangeInclusive(firstN));
        }
        if (!originalLineRange || !modifiedLineRange) {
            this.hideEditsPreview();
            return;
        }
        const hiddenOriginal = invertLineRange(originalLineRange, textModel0);
        const hiddenModified = invertLineRange(modifiedLineRange, textModelN);
        this._previewDiffEditor.value.getOriginalEditor().setHiddenAreas(( hiddenOriginal.map(lr => asRange(lr, textModel0))), 'diff-hidden');
        this._previewDiffEditor.value.getModifiedEditor().setHiddenAreas(( hiddenModified.map(lr => asRange(lr, textModelN))), 'diff-hidden');
        this._previewDiffEditor.value.revealLine(modifiedLineRange.startLineNumber, 1 );
        this._onDidChangeHeight.fire();
    }
    hideEditsPreview() {
        this._elements.previewDiff.classList.add('hidden');
        if (this._previewDiffEditor.hasValue) {
            this._previewDiffEditor.value.setModel(null);
        }
        this._previewDiffModel.clear();
        this._onDidChangeHeight.fire();
    }
    async showCreatePreview(model) {
        this._elements.previewCreateTitle.classList.remove('hidden');
        this._elements.previewCreate.classList.remove('hidden');
        const ref = await this._textModelResolverService.createModelReference(model.resource);
        this._previewCreateDispoable.value = ref;
        this._previewCreateTitle.element.setFile(model.resource, { fileKind: FileKind.FILE });
        this._previewCreateEditor.value.setModel(ref.object.textEditorModel);
        this._onDidChangeHeight.fire();
    }
    hideCreatePreview() {
        this._elements.previewCreateTitle.classList.add('hidden');
        this._elements.previewCreate.classList.add('hidden');
        this._previewCreateEditor.rawValue?.setModel(null);
        this._previewCreateDispoable.clear();
        this._previewCreateTitle.element.clear();
        this._onDidChangeHeight.fire();
    }
    showsAnyPreview() {
        return !this._elements.previewDiff.classList.contains('hidden') ||
            !this._elements.previewCreate.classList.contains('hidden');
    }
    updateSlashCommands(commands) {
        this._slashCommands.clear();
        if (commands.length === 0) {
            return;
        }
        this._slashCommandDetails = ( commands.filter(c => c.command && c.detail).map(c => { return { command: c.command, detail: c.detail }; }));
        const selector = { scheme: this._inputModel.uri.scheme, pattern: this._inputModel.uri.path, language: this._inputModel.getLanguageId() };
        this._slashCommands.add(this._languageFeaturesService.completionProvider.register(selector, new (class {
            constructor() {
                this._debugDisplayName = 'InlineChatSlashCommandProvider';
                this.triggerCharacters = ['/'];
            }
            provideCompletionItems(_model, position) {
                if (position.lineNumber !== 1 && position.column !== 1) {
                    return undefined;
                }
                const suggestions = ( commands.map(command => {
                    const withSlash = `/${command.command}`;
                    return {
                        label: { label: withSlash, description: command.detail },
                        insertText: `${withSlash} $0`,
                        insertTextRules: 4 ,
                        kind: 18 ,
                        range: ( new Range(1, 1, 1, 1)),
                        command: command.executeImmediately ? { id: 'inlineChat.accept', title: withSlash } : undefined
                    };
                }));
                return { suggestions };
            }
        })));
        const decorations = this._inputEditor.createDecorationsCollection();
        const updateSlashDecorations = () => {
            this._slashCommandContentWidget.hide();
            this._elements.detectedIntent.classList.toggle('hidden', true);
            const newDecorations = [];
            for (const command of commands) {
                const withSlash = `/${command.command}`;
                const firstLine = this._inputModel.getLineContent(1);
                if (firstLine.startsWith(withSlash)) {
                    newDecorations.push({
                        range: ( new Range(1, 1, 1, withSlash.length + 1)),
                        options: {
                            description: 'inline-chat-slash-command',
                            inlineClassName: 'inline-chat-slash-command',
                            after: {
                                content: ' '
                            }
                        }
                    });
                    this._slashCommandContentWidget.setCommandText(command.command);
                    this._slashCommandContentWidget.show();
                    if (firstLine === `/${command.command}`) {
                        newDecorations.push({
                            range: ( new Range(1, withSlash.length + 1, 1, withSlash.length + 2)),
                            options: {
                                description: 'inline-chat-slash-command-detail',
                                after: {
                                    content: `${command.detail}`,
                                    inlineClassName: 'inline-chat-slash-command-detail'
                                }
                            }
                        });
                    }
                    break;
                }
            }
            decorations.set(newDecorations);
        };
        this._slashCommands.add(this._inputEditor.onDidChangeModelContent(updateSlashDecorations));
        updateSlashDecorations();
    }
    showAccessibleHunk(session, hunkData) {
        this._elements.accessibleViewer.classList.remove('hidden');
        this._accessibleViewer.clear();
        this._accessibleViewer.value = this._instantiationService.createInstance(HunkAccessibleDiffViewer, this._elements.accessibleViewer, session, hunkData, ( new AccessibleHunk(this.parentEditor, session, hunkData)));
        this._onDidChangeHeight.fire();
    }
};
InlineChatWidget = InlineChatWidget_1 = ( __decorate([
    ( __param(2, IModelService)),
    ( __param(3, IContextKeyService)),
    ( __param(4, ILanguageFeaturesService)),
    ( __param(5, IKeybindingService)),
    ( __param(6, IInstantiationService)),
    ( __param(7, IAccessibilityService)),
    ( __param(8, IConfigurationService)),
    ( __param(9, IAccessibleViewService)),
    ( __param(10, ILogService)),
    ( __param(11, ITextModelService)),
    ( __param(12, IChatAgentService))
], InlineChatWidget));
let InlineChatZoneWidget = class InlineChatZoneWidget extends ZoneWidget {
    constructor(editor, _instaService, contextKeyService) {
        super(editor, { showFrame: false, showArrow: false, isAccessible: true, className: 'inline-chat-widget', keepEditorSelection: true, showInHiddenAreas: true, ordinal: 10000 });
        this._instaService = _instaService;
        this._ctxVisible = CTX_INLINE_CHAT_VISIBLE.bindTo(contextKeyService);
        this._ctxCursorPosition = CTX_INLINE_CHAT_OUTER_CURSOR_POSITION.bindTo(contextKeyService);
        this._disposables.add(toDisposable(() => {
            this._ctxVisible.reset();
            this._ctxCursorPosition.reset();
        }));
        this.widget = this._instaService.createInstance(InlineChatWidget, this.editor, {
            menuId: MENU_INLINE_CHAT_INPUT,
            widgetMenuId: MENU_INLINE_CHAT_WIDGET,
            statusMenuId: MENU_INLINE_CHAT_WIDGET_STATUS,
            feedbackMenuId: MENU_INLINE_CHAT_WIDGET_FEEDBACK
        });
        this._disposables.add(this.widget.onDidChangeHeight(() => this._relayout()));
        this._disposables.add(this.widget);
        this.create();
        this._disposables.add(addDisposableListener(this.domNode, 'click', e => {
            if (!this.widget.hasFocus()) {
                this.widget.focus();
            }
        }, true));
        const updateCursorIsAboveContextKey = () => {
            if (!this.position || !this.editor.hasModel()) {
                this._ctxCursorPosition.reset();
            }
            else if (this.position.lineNumber === this.editor.getPosition().lineNumber) {
                this._ctxCursorPosition.set('above');
            }
            else if (this.position.lineNumber + 1 === this.editor.getPosition().lineNumber) {
                this._ctxCursorPosition.set('below');
            }
            else {
                this._ctxCursorPosition.reset();
            }
        };
        this._disposables.add(this.editor.onDidChangeCursorPosition(e => updateCursorIsAboveContextKey()));
        this._disposables.add(this.editor.onDidFocusEditorText(e => updateCursorIsAboveContextKey()));
        updateCursorIsAboveContextKey();
    }
    _fillContainer(container) {
        container.appendChild(this.widget.domNode);
    }
    _doLayout(heightInPixel) {
        const maxWidth = !this.widget.showsAnyPreview() ? 640 : Number.MAX_SAFE_INTEGER;
        const width = Math.min(maxWidth, this._availableSpaceGivenIndentation(this._indentationWidth));
        this._dimension = ( new Dimension(width, heightInPixel));
        this.widget.domNode.style.width = `${width}px`;
        this.widget.layout(this._dimension);
    }
    _availableSpaceGivenIndentation(indentationWidth) {
        const info = this.editor.getLayoutInfo();
        return info.contentWidth - (info.glyphMarginWidth + info.decorationsWidth + (indentationWidth ?? 0));
    }
    _computeHeightInLines() {
        const lineHeight = this.editor.getOption(67 );
        return this.widget.getHeight() / lineHeight;
    }
    _relayout() {
        if (this._dimension) {
            this._doLayout(this._dimension.height);
        }
        super._relayout(this._computeHeightInLines());
    }
    show(position) {
        super.show(position, this._computeHeightInLines());
        this.widget.focus();
        this._ctxVisible.set(true);
    }
    _getWidth(info) {
        return info.width - info.minimap.minimapWidth;
    }
    updateBackgroundColor(newPosition, wholeRange) {
        assertType(this.container);
        const widgetLineNumber = newPosition.lineNumber;
        this.container.classList.toggle('inside-selection', widgetLineNumber > wholeRange.startLineNumber && widgetLineNumber < wholeRange.endLineNumber);
    }
    _calculateIndentationWidth(position) {
        const viewModel = this.editor._getViewModel();
        if (!viewModel) {
            return 0;
        }
        const visibleRange = viewModel.getCompletelyVisibleViewRange();
        const startLineVisibleRange = visibleRange.startLineNumber;
        const positionLine = position.lineNumber;
        let indentationLineNumber;
        let indentationLevel;
        for (let lineNumber = positionLine; lineNumber >= startLineVisibleRange; lineNumber--) {
            const currentIndentationLevel = viewModel.getLineFirstNonWhitespaceColumn(lineNumber);
            if (currentIndentationLevel !== 0) {
                indentationLineNumber = lineNumber;
                indentationLevel = currentIndentationLevel;
                break;
            }
        }
        return this.editor.getOffsetForColumn(indentationLineNumber ?? positionLine, indentationLevel ?? viewModel.getLineFirstNonWhitespaceColumn(positionLine));
    }
    setContainerMargins() {
        assertType(this.container);
        const info = this.editor.getLayoutInfo();
        const marginWithoutIndentation = info.glyphMarginWidth + info.decorationsWidth + info.lineNumbersWidth;
        this.container.style.marginLeft = `${marginWithoutIndentation}px`;
    }
    setWidgetMargins(position) {
        const indentationWidth = this._calculateIndentationWidth(position);
        if (this._indentationWidth === indentationWidth) {
            return;
        }
        this._indentationWidth = this._availableSpaceGivenIndentation(indentationWidth) > 400 ? indentationWidth : 0;
        this.widget.domNode.style.marginLeft = `${this._indentationWidth}px`;
        this.widget.domNode.style.marginRight = `${this.editor.getLayoutInfo().minimap.minimapWidth}px`;
    }
    hide() {
        this.container.classList.remove('inside-selection');
        this._ctxVisible.reset();
        this._ctxCursorPosition.reset();
        this.widget.reset();
        super.hide();
        status(( localizeWithPath(
            'vs/workbench/contrib/inlineChat/browser/inlineChatWidget',
            'inlineChatClosed',
            'Closed inline chat widget'
        )));
    }
};
InlineChatZoneWidget = ( __decorate([
    ( __param(1, IInstantiationService)),
    ( __param(2, IContextKeyService))
], InlineChatZoneWidget));
let HunkAccessibleDiffViewer = HunkAccessibleDiffViewer_1 = class HunkAccessibleDiffViewer extends AccessibleDiffViewer {
    set width(value) {
        this._width2.set(value, undefined);
    }
    constructor(parentNode, session, hunk, models, instantiationService) {
        const width = observableValue('width', 0);
        const diff = observableValue('diff', HunkAccessibleDiffViewer_1._asMapping(hunk));
        const diffs = derived(r => [diff.read(r)]);
        const lines = Math.min(10, 8 + diff.get().changedLineCount);
        const height = models.getModifiedOptions().get(67 ) * lines;
        super(parentNode, constObservable(true), () => { }, constObservable(false), width, constObservable(height), diffs, models, instantiationService);
        this.height = height;
        this._width2 = width;
        this._store.add(session.textModelN.onDidChangeContent(() => {
            diff.set(HunkAccessibleDiffViewer_1._asMapping(hunk), undefined);
        }));
    }
    static _asMapping(hunk) {
        const ranges0 = hunk.getRanges0();
        const rangesN = hunk.getRangesN();
        const originalLineRange = LineRange.fromRangeInclusive(ranges0[0]);
        const modifiedLineRange = LineRange.fromRangeInclusive(rangesN[0]);
        const innerChanges = [];
        for (let i = 1; i < ranges0.length; i++) {
            innerChanges.push(( new RangeMapping(ranges0[i], rangesN[i])));
        }
        return ( new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, innerChanges));
    }
};
HunkAccessibleDiffViewer = HunkAccessibleDiffViewer_1 = ( __decorate([
    ( __param(4, IInstantiationService))
], HunkAccessibleDiffViewer));
class AccessibleHunk {
    constructor(_editor, _session, _hunk) {
        this._editor = _editor;
        this._session = _session;
        this._hunk = _hunk;
    }
    getOriginalModel() {
        return this._session.textModel0;
    }
    getModifiedModel() {
        return this._session.textModelN;
    }
    getOriginalOptions() {
        return this._editor.getOptions();
    }
    getModifiedOptions() {
        return this._editor.getOptions();
    }
    originalReveal(range) {
    }
    modifiedReveal(range) {
        this._editor.revealRangeInCenterIfOutsideViewport(range || this._hunk.getRangesN()[0], 0 );
    }
    modifiedSetSelection(range) {
    }
    modifiedFocus() {
        this._editor.focus();
    }
    getModifiedPosition() {
        return this._hunk.getRangesN()[0].getStartPosition();
    }
}
export { InlineChatWidget, InlineChatZoneWidget, _inputEditorOptions };
