import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { renderMarkdownAsPlaintext } from '../../../../base/browser/markdownRenderer.js';
import { alert } from '../../../../base/browser/ui/aria/aria.js';
import { raceCancellationError, raceCancellation, Barrier, Queue } from '../../../../base/common/async.js';
import { CancellationTokenSource } from '../../../../base/common/cancellation.js';
import { toErrorMessage } from '../../../../base/common/errorMessage.js';
import { onUnexpectedError } from '../../../../base/common/errors.js';
import { Emitter, Event } from '../../../../base/common/event.js';
import { MarkdownString } from '../../../../base/common/htmlContent.js';
import { Lazy } from '../../../../base/common/lazy.js';
import { DisposableStore, MutableDisposable, toDisposable } from '../../../../base/common/lifecycle.js';
import { MovingAverage } from '../../../../base/common/numbers.js';
import { StopWatch } from '../../../../base/common/stopwatch.js';
import { assertType } from '../../../../base/common/types.js';
import { generateUuid } from '../../../../base/common/uuid.js';
import { IBulkEditService } from '../../../../editor/browser/services/bulkEditService.js';
import { Position } from '../../../../editor/common/core/position.js';
import { Range } from '../../../../editor/common/core/range.js';
import { Selection } from '../../../../editor/common/core/selection.js';
import { TextEdit } from '../../../../editor/common/languages.js';
import { IEditorWorkerService } from '../../../../editor/common/services/editorWorker.js';
import { InlineCompletionsController } from '../../../../editor/contrib/inlineCompletions/browser/inlineCompletionsController.js';
import { localizeWithPath } from '../../../../nls.js';
import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';
import '../../../../../../../override/vs/platform/dialogs/common/dialogs.js';
import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
import { ILogService } from '../../../../platform/log/common/log.js';
import { Progress } from '../../../../platform/progress/common/progress.js';
import { IStorageService } from '../../../../platform/storage/common/storage.js';
import { IChatWidgetService, IChatAccessibilityService } from '../../chat/browser/chat.js';
import { IChatAgentService } from '../../chat/common/chatAgents.js';
import { chatSubcommandLeader, chatAgentLeader } from '../../chat/common/chatParserTypes.js';
import { IChatService } from '../../chat/common/chatService.js';
import { IInlineChatSavingService } from './inlineChatSavingService.js';
import { ReplyResponse, SessionPrompt, SessionExchange, EmptyResponse, ErrorResponse, ExpansionState, Session } from './inlineChatSession.js';
import { IInlineChatSessionService } from './inlineChatSessionService.js';
import { LiveStrategy, LivePreviewStrategy, PreviewStrategy } from './inlineChatStrategies.js';
import { InlineChatZoneWidget } from './inlineChatWidget.js';
import { INLINE_CHAT_ID, CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST, CTX_INLINE_CHAT_DID_EDIT, CTX_INLINE_CHAT_USER_DID_EDIT, CTX_INLINE_CHAT_RESPONSE_TYPES, CTX_INLINE_CHAT_LAST_FEEDBACK, CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING } from '../common/inlineChat.js';
import { ICommandService } from '../../../../platform/commands/common/commands.js';
import { IDialogService } from '../../../../platform/dialogs/common/dialogs.js';
var InlineChatController_1;
class InlineChatRunOptions {
    static isInteractiveEditorOptions(options) {
        const { initialSelection, initialRange, message, autoSend, position, existingExchange, existingSession } = options;
        if (typeof message !== 'undefined' && typeof message !== 'string'
            || typeof autoSend !== 'undefined' && typeof autoSend !== 'boolean'
            || typeof initialRange !== 'undefined' && !Range.isIRange(initialRange)
            || typeof initialSelection !== 'undefined' && !Selection.isISelection(initialSelection)
            || typeof position !== 'undefined' && !Position.isIPosition(position)
            || typeof existingSession !== 'undefined' && !(existingSession instanceof Session)
            || typeof existingExchange !== 'undefined' && typeof existingExchange !== 'object') {
            return false;
        }
        return true;
    }
}
let InlineChatController = class InlineChatController {
    static { InlineChatController_1 = this; }
    static get(editor) {
        return editor.getContribution(INLINE_CHAT_ID);
    }
    static { this._storageKey = 'inline-chat-history'; }
    static { this._promptHistory = []; }
    constructor(_editor, _instaService, _inlineChatSessionService, _inlineChatSavingService, _editorWorkerService, _logService, _configurationService, _dialogService, contextKeyService, _chatAccessibilityService, _chatAgentService, _bulkEditService, _storageService, _commandService) {
        this._editor = _editor;
        this._instaService = _instaService;
        this._inlineChatSessionService = _inlineChatSessionService;
        this._inlineChatSavingService = _inlineChatSavingService;
        this._editorWorkerService = _editorWorkerService;
        this._logService = _logService;
        this._configurationService = _configurationService;
        this._dialogService = _dialogService;
        this._chatAccessibilityService = _chatAccessibilityService;
        this._chatAgentService = _chatAgentService;
        this._bulkEditService = _bulkEditService;
        this._storageService = _storageService;
        this._commandService = _commandService;
        this._historyOffset = -1;
        this._historyCandidate = '';
        this._isDisposed = false;
        this._store = ( new DisposableStore());
        this._messages = this._store.add(( new Emitter()));
        this._onWillStartSession = this._store.add(( new Emitter()));
        this.onWillStartSession = this._onWillStartSession.event;
        this.onDidAcceptInput = Event.filter(this._messages.event, m => m === 32 , this._store);
        this.onDidCancelInput = Event.filter(this._messages.event, m => m === 16  || m === 2 , this._store);
        this._sessionStore = this._store.add(( new DisposableStore()));
        this._stashedSession = this._store.add(( new MutableDisposable()));
        this._forcedPlaceholder = undefined;
        this._ctxHasActiveRequest = CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST.bindTo(contextKeyService);
        this._ctxDidEdit = CTX_INLINE_CHAT_DID_EDIT.bindTo(contextKeyService);
        this._ctxUserDidEdit = CTX_INLINE_CHAT_USER_DID_EDIT.bindTo(contextKeyService);
        this._ctxResponseTypes = CTX_INLINE_CHAT_RESPONSE_TYPES.bindTo(contextKeyService);
        this._ctxLastFeedbackKind = CTX_INLINE_CHAT_LAST_FEEDBACK.bindTo(contextKeyService);
        this._ctxSupportIssueReporting = CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING.bindTo(contextKeyService);
        this._zone = ( new Lazy(
            () => this._store.add(_instaService.createInstance(InlineChatZoneWidget, this._editor))
        ));
        this._store.add(this._editor.onDidChangeModel(async (e) => {
            if (this._session || !e.newModelUrl) {
                return;
            }
            const existingSession = this._inlineChatSessionService.getSession(this._editor, e.newModelUrl);
            if (!existingSession) {
                return;
            }
            this._log('session RESUMING after model change', e);
            await this.run({ existingSession });
        }));
        this._store.add(this._inlineChatSessionService.onDidEndSession(e => {
            if (e.session === this._session && e.endedByExternalCause) {
                this._log('session ENDED by external cause');
                this._session = undefined;
                this._strategy?.cancel();
                this._resetWidget();
                this.cancelSession();
            }
        }));
        this._store.add(this._inlineChatSessionService.onDidMoveSession(async (e) => {
            if (e.editor === this._editor) {
                this._log('session RESUMING after move', e);
                await this.run({ existingSession: e.session });
            }
        }));
        this._log('NEW controller');
        InlineChatController_1._promptHistory = JSON.parse(_storageService.get(InlineChatController_1._storageKey, 0 , '[]'));
        this._historyUpdate = (prompt) => {
            const idx = InlineChatController_1._promptHistory.indexOf(prompt);
            if (idx >= 0) {
                InlineChatController_1._promptHistory.splice(idx, 1);
            }
            InlineChatController_1._promptHistory.unshift(prompt);
            this._historyOffset = -1;
            this._historyCandidate = '';
            this._storageService.store(InlineChatController_1._storageKey, JSON.stringify(InlineChatController_1._promptHistory), 0 , 0 );
        };
    }
    dispose() {
        if (this._currentRun) {
            this._messages.fire(((this._session?.lastExchange ? 4  : 2) ));
        }
        this._store.dispose();
        this._isDisposed = true;
        this._log('DISPOSED controller');
    }
    _log(message, ...more) {
        if (message instanceof Error) {
            this._logService.error(message, ...more);
        }
        else {
            this._logService.trace(`[IE] (editor:${this._editor.getId()})${message}`, ...more);
        }
    }
    getMessage() {
        return this._zone.value.widget.responseContent;
    }
    getId() {
        return INLINE_CHAT_ID;
    }
    _getMode() {
        return this._configurationService.getValue("inlineChat.mode" );
    }
    getWidgetPosition() {
        return this._zone.value.position;
    }
    async run(options = {}) {
        try {
            this.finishExistingSession();
            if (this._currentRun) {
                await this._currentRun;
            }
            if (options.initialSelection) {
                this._editor.setSelection(options.initialSelection);
            }
            this._historyOffset = -1;
            this._historyCandidate = '';
            this._stashedSession.clear();
            this._onWillStartSession.fire();
            this._currentRun = this._nextState("CREATE_SESSION" , options);
            await this._currentRun;
        }
        catch (error) {
            onUnexpectedError(error);
            if (this._session) {
                this._inlineChatSessionService.releaseSession(this._session);
            }
            this["PAUSE" ]();
        }
        finally {
            this._currentRun = undefined;
        }
    }
    async _nextState(state, options) {
        let nextState = state;
        while (nextState && !this._isDisposed) {
            this._log('setState to ', nextState);
            nextState = await this[nextState](options);
        }
    }
    async ["CREATE_SESSION" ](options) {
        assertType(this._session === undefined);
        assertType(this._editor.hasModel());
        let session = options.existingSession;
        let initPosition;
        if (options.position) {
            initPosition = Position.lift(options.position).delta(-1);
            delete options.position;
        }
        this._showWidget(true, initPosition);
        this._updatePlaceholder();
        if (!session) {
            const createSessionCts = ( new CancellationTokenSource());
            const msgListener = Event.once(this._messages.event)(m => {
                this._log('state=_createSession) message received', m);
                if (m === 32 ) {
                    options.autoSend = true;
                    this._zone.value.widget.updateProgress(true);
                    this._zone.value.widget.updateInfo(( localizeWithPath(
                        'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                        'welcome.2',
                        "Getting ready..."
                    )));
                }
                else {
                    createSessionCts.cancel();
                }
            });
            session = await this._inlineChatSessionService.createSession(this._editor, { editMode: this._getMode(), wholeRange: options.initialRange }, createSessionCts.token);
            createSessionCts.dispose();
            msgListener.dispose();
            if (createSessionCts.token.isCancellationRequested) {
                if (session) {
                    this._inlineChatSessionService.releaseSession(session);
                }
                return "CANCEL" ;
            }
        }
        delete options.initialRange;
        delete options.existingSession;
        if (!session) {
            this._dialogService.info(( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                'create.fail',
                "Failed to start editor chat"
            )), ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                'create.fail.detail',
                "Please consult the error log and try again later."
            )));
            return "CANCEL" ;
        }
        switch (session.editMode) {
            case "preview" :
                this._strategy = this._instaService.createInstance(PreviewStrategy, session, this._editor, this._zone.value);
                break;
            case "livePreview" :
                this._strategy = this._instaService.createInstance(LivePreviewStrategy, session, this._editor, this._zone.value);
                break;
            case "live" :
            default:
                this._strategy = this._instaService.createInstance(LiveStrategy, session, this._editor, this._zone.value);
                break;
        }
        this._session = session;
        return "INIT_UI" ;
    }
    async ["INIT_UI" ](options) {
        assertType(this._session);
        assertType(this._strategy);
        InlineCompletionsController.get(this._editor)?.hide();
        this._sessionStore.clear();
        this._sessionStore.add(this._zone.value.widget.onRequestWithoutIntentDetection(async () => {
            options.withIntentDetection = false;
            this.regenerate();
        }));
        const wholeRangeDecoration = this._editor.createDecorationsCollection();
        const updateWholeRangeDecoration = () => {
            const newDecorations = this._strategy?.getWholeRangeDecoration() ?? [];
            wholeRangeDecoration.set(newDecorations);
        };
        this._sessionStore.add(toDisposable(() => wholeRangeDecoration.clear()));
        this._sessionStore.add(this._session.wholeRange.onDidChange(updateWholeRangeDecoration));
        updateWholeRangeDecoration();
        this._zone.value.widget.updateSlashCommands(this._session.session.slashCommands ?? []);
        this._updatePlaceholder();
        this._zone.value.widget.updateInfo(this._session.session.message ?? ( localizeWithPath(
            'vs/workbench/contrib/inlineChat/browser/inlineChatController',
            'welcome.1',
            "AI-generated code may be incorrect"
        )));
        this._zone.value.widget.preferredExpansionState = this._session.lastExpansionState;
        this._zone.value.widget.value = this._session.session.input ?? this._session.lastInput?.value ?? this._zone.value.widget.value;
        if (this._session.session.input) {
            this._zone.value.widget.selectAll();
        }
        this._showWidget(true);
        this._sessionStore.add(this._editor.onDidChangeModel((e) => {
            const msg = this._session?.lastExchange
                ? 4
                : 2 ;
            this._log('model changed, pause or cancel session', msg, e);
            this._messages.fire(msg);
        }));
        const altVersionNow = this._editor.getModel()?.getAlternativeVersionId();
        this._sessionStore.add(this._editor.onDidChangeModelContent(e => {
            if (!this._session?.hunkData.ignoreTextModelNChanges) {
                this._ctxUserDidEdit.set(altVersionNow !== this._editor.getModel()?.getAlternativeVersionId());
            }
            if (this._session?.hunkData.ignoreTextModelNChanges || this._strategy?.hasFocus()) {
                return;
            }
            const wholeRange = this._session.wholeRange;
            let shouldFinishSession = false;
            if (this._configurationService.getValue("inlineChat.finishOnType" )) {
                for (const { range } of e.changes) {
                    shouldFinishSession = !Range.areIntersectingOrTouching(range, wholeRange.value);
                }
            }
            this._session.recordExternalEditOccurred(shouldFinishSession);
            if (shouldFinishSession) {
                this._log('text changed outside of whole range, FINISH session');
                this.finishExistingSession();
            }
        }));
        this._ctxSupportIssueReporting.set(this._session.provider.supportIssueReporting ?? false);
        if (!this._session.lastExchange) {
            return "WAIT_FOR_INPUT" ;
        }
        else if (options.isUnstashed) {
            delete options.isUnstashed;
            return "APPLY_RESPONSE" ;
        }
        else {
            return "SHOW_RESPONSE" ;
        }
    }
    async ["WAIT_FOR_INPUT" ](options) {
        assertType(this._session);
        assertType(this._strategy);
        this._updatePlaceholder();
        if (options.existingExchange) {
            options.message = options.existingExchange.prompt;
            options.autoSend = true;
        }
        if (options.message) {
            this.updateInput(options.message);
            alert(options.message);
            delete options.message;
        }
        let message = 0 ;
        if (options.autoSend) {
            message = 32 ;
            delete options.autoSend;
        }
        else {
            const barrier = ( new Barrier());
            const store = ( new DisposableStore());
            store.add(this._strategy.onDidAccept(() => this.acceptSession()));
            store.add(this._strategy.onDidDiscard(() => this.cancelSession()));
            store.add(Event.once(this._messages.event)(m => {
                this._log('state=_waitForInput) message received', m);
                message = m;
                barrier.open();
            }));
            await barrier.wait();
            store.dispose();
        }
        if (message & ((16  | 2) )) {
            return "CANCEL" ;
        }
        if (message & 4 ) {
            return "PAUSE" ;
        }
        if (message & 1 ) {
            this._zone.value.widget.selectAll(false);
            return "DONE" ;
        }
        if (message & 64  && this._session.lastExchange) {
            const { lastExchange } = this._session;
            if (options.withIntentDetection === undefined) {
                this._session.addInput(lastExchange.prompt.retry());
            }
            if (lastExchange.response instanceof ReplyResponse) {
                try {
                    this._session.hunkData.ignoreTextModelNChanges = true;
                    await this._strategy.undoChanges(lastExchange.response.modelAltVersionId);
                }
                finally {
                    this._session.hunkData.ignoreTextModelNChanges = false;
                }
            }
            return "MAKE_REQUEST" ;
        }
        if (!this.getInput()) {
            return "WAIT_FOR_INPUT" ;
        }
        const input = this.getInput();
        this._historyUpdate(input);
        const refer = this._session.session.slashCommands?.some(value => value.refer && input.startsWith(`/${value.command}`));
        if (refer) {
            this._log('[IE] seeing refer command, continuing outside editor', this._session.provider.debugName);
            this._editor.setSelection(this._session.wholeRange.value);
            let massagedInput = input;
            if (input.startsWith(chatSubcommandLeader)) {
                const withoutSubCommandLeader = input.slice(1);
                const cts = ( new CancellationTokenSource());
                this._sessionStore.add(cts);
                for (const agent of this._chatAgentService.getAgents()) {
                    const commands = await agent.provideSlashCommands(undefined, [], cts.token);
                    if (commands.find((command) => withoutSubCommandLeader.startsWith(command.name))) {
                        massagedInput = `${chatAgentLeader}${agent.id} ${input}`;
                        break;
                    }
                }
            }
            this._instaService.invokeFunction(sendRequest, massagedInput);
            if (!this._session.lastExchange) {
                return "DONE" ;
            }
            return "WAIT_FOR_INPUT" ;
        }
        this._session.addInput(( new SessionPrompt(input)));
        return "MAKE_REQUEST" ;
    }
    async ["MAKE_REQUEST" ](options) {
        assertType(this._editor.hasModel());
        assertType(this._session);
        assertType(this._strategy);
        assertType(this._session.lastInput);
        const requestCts = ( new CancellationTokenSource());
        let message = 0 ;
        const msgListener = Event.once(this._messages.event)(m => {
            this._log('state=_makeRequest) message received', m);
            message = m;
            requestCts.cancel();
        });
        const typeListener = this._zone.value.widget.onDidChangeInput(() => requestCts.cancel());
        const requestClock = StopWatch.create();
        const request = {
            requestId: generateUuid(),
            prompt: this._session.lastInput.value,
            attempt: this._session.lastInput.attempt,
            selection: this._editor.getSelection(),
            wholeRange: this._session.wholeRange.trackedInitialRange,
            live: this._session.editMode !== "preview" ,
            previewDocument: this._session.textModelN.uri,
            withIntentDetection: options.withIntentDetection ?? true ,
        };
        delete options.withIntentDetection;
        const modelAltVersionIdNow = this._session.textModelN.getAlternativeVersionId();
        const progressEdits = [];
        const progressiveEditsAvgDuration = ( new MovingAverage());
        const progressiveEditsCts = ( new CancellationTokenSource(requestCts.token));
        const progressiveEditsClock = StopWatch.create();
        const progressiveEditsQueue = ( new Queue());
        let progressiveChatResponse;
        const progress = ( new Progress(data => {
            this._log('received chunk', data, request);
            if (requestCts.token.isCancellationRequested) {
                return;
            }
            if (data.message) {
                this._zone.value.widget.updateToolbar(false);
                this._zone.value.widget.updateInfo(data.message);
            }
            if (data.slashCommand) {
                const valueNow = this.getInput();
                if (!valueNow.startsWith('/')) {
                    this._zone.value.widget.updateSlashCommandUsed(data.slashCommand);
                }
            }
            if (data.edits?.length) {
                if (!request.live) {
                    throw new Error('Progress in NOT supported in non-live mode');
                }
                progressEdits.push(data.edits);
                progressiveEditsAvgDuration.update(progressiveEditsClock.elapsed());
                progressiveEditsClock.reset();
                progressiveEditsQueue.queue(async () => {
                    const startThen = this._session.wholeRange.value.getStartPosition();
                    await this._makeChanges(data.edits, data.editsShouldBeInstant
                        ? undefined
                        : { duration: progressiveEditsAvgDuration.value, token: progressiveEditsCts.token });
                    const startNow = this._session.wholeRange.value.getStartPosition();
                    if (!startNow.equals(startThen) || !this._zone.value.position?.equals(startNow)) {
                        this._showWidget(false, startNow.delta(-1));
                    }
                });
            }
            if (data.markdownFragment) {
                if (!progressiveChatResponse) {
                    const message = {
                        message: ( new MarkdownString(
                            data.markdownFragment,
                            { supportThemeIcons: true, supportHtml: true, isTrusted: false }
                        )),
                        providerId: this._session.provider.debugName,
                        requestId: request.requestId,
                    };
                    progressiveChatResponse = this._zone.value.widget.updateChatMessage(message, true);
                }
                else {
                    progressiveChatResponse.appendContent(data.markdownFragment);
                }
            }
        }));
        let a11yResponse;
        const a11yVerboseInlineChat = this._configurationService.getValue('accessibility.verbosity.inlineChat') === true;
        const requestId = this._chatAccessibilityService.acceptRequest();
        let task;
        if (options.existingExchange) {
            task = options.existingExchange.response;
            delete options.existingExchange;
            this._log('using READY-response', this._session.provider.debugName, this._session.session);
        }
        else {
            task = this._session.provider.provideResponse(this._session.session, request, progress, requestCts.token);
            this._log('request started', this._session.provider.debugName, this._session.session, request);
        }
        let response;
        let reply;
        try {
            this._zone.value.widget.updateChatMessage(undefined);
            this._zone.value.widget.updateFollowUps(undefined);
            this._zone.value.widget.updateProgress(true);
            this._zone.value.widget.updateInfo(!this._session.lastExchange ? ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                'thinking',
                "Thinking\u2026"
            )) : '');
            this._ctxHasActiveRequest.set(true);
            reply = await raceCancellationError(Promise.resolve(task), requestCts.token);
            await progressiveEditsQueue.whenIdle();
            if (progressiveChatResponse) {
                progressiveChatResponse.cancel();
            }
            if (!reply) {
                response = ( new EmptyResponse());
                a11yResponse = ( localizeWithPath(
                    'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                    'empty',
                    "No results, please refine your input and try again"
                ));
            }
            else {
                const markdownContents = reply.message ?? ( new MarkdownString('', { supportThemeIcons: true, supportHtml: true, isTrusted: false }));
                const replyResponse = response = this._instaService.createInstance(ReplyResponse, reply, markdownContents, this._session.textModelN.uri, modelAltVersionIdNow, progressEdits, request.requestId);
                for (let i = progressEdits.length; i < replyResponse.allLocalEdits.length; i++) {
                    await this._makeChanges(replyResponse.allLocalEdits[i], undefined);
                }
                const a11yMessageResponse = renderMarkdownAsPlaintext(replyResponse.mdContent);
                a11yResponse = a11yVerboseInlineChat
                    ? a11yMessageResponse ? ( localizeWithPath(
                    'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                    'editResponseMessage2',
                    "{0}, also review proposed changes in the diff editor.",
                    a11yMessageResponse
                )) : ( localizeWithPath(
                    'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                    'editResponseMessage',
                    "Review proposed changes in the diff editor."
                ))
                    : a11yMessageResponse;
            }
        }
        catch (e) {
            progressiveEditsQueue.clear();
            response = ( new ErrorResponse(e));
            a11yResponse = response.message;
        }
        finally {
            this._ctxHasActiveRequest.set(false);
            this._zone.value.widget.updateProgress(false);
            this._zone.value.widget.updateInfo('');
            this._zone.value.widget.updateToolbar(true);
            this._log('request took', requestClock.elapsed(), this._session.provider.debugName);
            this._chatAccessibilityService.acceptResponse(a11yResponse, requestId);
        }
        const diff = await this._editorWorkerService.computeDiff(this._session.textModel0.uri, this._session.textModelN.uri, { computeMoves: false, maxComputationTimeMs: Number.MAX_SAFE_INTEGER, ignoreTrimWhitespace: false }, 'advanced');
        this._session.wholeRange.fixup(diff?.changes ?? []);
        progressiveEditsCts.dispose(true);
        requestCts.dispose();
        msgListener.dispose();
        typeListener.dispose();
        if (response instanceof ReplyResponse) {
            await this._session.hunkData.recompute();
        }
        else if (request.live) {
            this._strategy?.undoChanges(modelAltVersionIdNow);
        }
        this._session.addExchange(( new SessionExchange(this._session.lastInput, response)));
        if (message & 2 ) {
            return "CANCEL" ;
        }
        else if (message & 4 ) {
            return "PAUSE" ;
        }
        else if (message & 1 ) {
            return "DONE" ;
        }
        else if (message & ((32  | 64) )) {
            return "MAKE_REQUEST" ;
        }
        else {
            return "APPLY_RESPONSE" ;
        }
    }
    async ["APPLY_RESPONSE" ]() {
        assertType(this._session);
        assertType(this._strategy);
        const { response } = this._session.lastExchange;
        if (response instanceof ReplyResponse && response.workspaceEdit) {
            this._bulkEditService.apply(response.workspaceEdit, { showPreview: true });
            return "CANCEL" ;
        }
        return "SHOW_RESPONSE" ;
    }
    async ["SHOW_RESPONSE" ]() {
        assertType(this._session);
        assertType(this._strategy);
        const { response } = this._session.lastExchange;
        let responseTypes;
        for (const { response } of this._session.exchanges) {
            const thisType = response instanceof ReplyResponse
                ? response.responseType
                : undefined;
            if (responseTypes === undefined) {
                responseTypes = thisType;
            }
            else if (responseTypes !== thisType) {
                responseTypes = "mixed" ;
                break;
            }
        }
        this._ctxResponseTypes.set(responseTypes);
        this._ctxDidEdit.set(this._session.hasChangedText);
        let newPosition;
        if (response instanceof EmptyResponse) {
            const status = ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                'empty',
                "No results, please refine your input and try again"
            ));
            this._zone.value.widget.updateStatus(status, { classes: ['warn'] });
            return "WAIT_FOR_INPUT" ;
        }
        else if (response instanceof ErrorResponse) {
            if (!response.isCancellation) {
                this._zone.value.widget.updateStatus(response.message, { classes: ['error'] });
            }
        }
        else if (response instanceof ReplyResponse) {
            this._zone.value.widget.updateStatus('');
            const message = { message: response.mdContent, providerId: this._session.provider.debugName, requestId: response.requestId };
            this._zone.value.widget.updateChatMessage(message);
            this._session.lastExpansionState = this._zone.value.widget.expansionState;
            this._zone.value.widget.updateToolbar(true);
            newPosition = await this._strategy.renderChanges(response);
            if (this._session.provider.provideFollowups) {
                const followupCts = ( new CancellationTokenSource());
                const msgListener = Event.once(this._messages.event)(() => {
                    followupCts.cancel();
                });
                const followupTask = this._session.provider.provideFollowups(this._session.session, response.raw, followupCts.token);
                this._log('followup request started', this._session.provider.debugName, this._session.session, response.raw);
                raceCancellation(Promise.resolve(followupTask), followupCts.token).then(followupReply => {
                    if (followupReply && this._session) {
                        this._log('followup request received', this._session.provider.debugName, this._session.session, followupReply);
                        this._zone.value.widget.updateFollowUps(followupReply, followup => {
                            if (followup.kind === 'reply') {
                                this.updateInput(followup.message);
                                this.acceptInput();
                            }
                            else {
                                this._commandService.executeCommand(followup.commandId, ...(followup.args ?? []));
                            }
                        });
                    }
                }).finally(() => {
                    msgListener.dispose();
                    followupCts.dispose();
                });
            }
        }
        this._showWidget(false, newPosition);
        return "WAIT_FOR_INPUT" ;
    }
    async ["PAUSE" ]() {
        this._resetWidget();
        this._strategy?.dispose?.();
        this._session = undefined;
    }
    async ["DONE" ]() {
        assertType(this._session);
        assertType(this._strategy);
        this._sessionStore.clear();
        try {
            await this._strategy.apply();
        }
        catch (err) {
            this._dialogService.error(( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                'err.apply',
                "Failed to apply changes.",
                toErrorMessage(err)
            )));
            this._log('FAILED to apply changes');
            this._log(err);
        }
        this._inlineChatSessionService.releaseSession(this._session);
        this._resetWidget();
        this._strategy?.dispose();
        this._strategy = undefined;
        this._session = undefined;
    }
    async ["CANCEL" ]() {
        if (this._session) {
            assertType(this._strategy);
            this._sessionStore.clear();
            const shouldStash = !this._session.isUnstashed && !!this._session.lastExchange && this._session.hunkData.size === this._session.hunkData.pending;
            let undoCancelEdits = [];
            try {
                undoCancelEdits = this._strategy.cancel();
            }
            catch (err) {
                this._dialogService.error(( localizeWithPath(
                    'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                    'err.discard',
                    "Failed to discard changes.",
                    toErrorMessage(err)
                )));
                this._log('FAILED to discard changes');
                this._log(err);
            }
            this._stashedSession.clear();
            if (shouldStash) {
                this._stashedSession.value = this._inlineChatSessionService.stashSession(this._session, this._editor, undoCancelEdits);
            }
            else {
                this._inlineChatSessionService.releaseSession(this._session);
            }
        }
        this._resetWidget();
        this._strategy?.dispose();
        this._strategy = undefined;
        this._session = undefined;
    }
    _showWidget(initialRender = false, position) {
        assertType(this._editor.hasModel());
        let widgetPosition;
        if (position) {
            widgetPosition = position;
        }
        else if (this._zone.value.position) {
            if (this._zone.value.position.lineNumber === 1) {
                widgetPosition = this._zone.value.position.delta(-1);
            }
            else {
                widgetPosition = this._zone.value.position;
            }
        }
        else {
            widgetPosition = this._editor.getSelection().getStartPosition().delta(-1);
        }
        if (initialRender) {
            this._zone.value.setContainerMargins();
        }
        if (this._session && !position && (this._session.hasChangedText || this._session.lastExchange)) {
            widgetPosition = this._session.wholeRange.value.getStartPosition().delta(-1);
        }
        if (this._session) {
            this._zone.value.updateBackgroundColor(widgetPosition, this._session.wholeRange.value);
        }
        if (!this._zone.value.position) {
            this._zone.value.setWidgetMargins(widgetPosition);
            this._zone.value.show(widgetPosition);
        }
        else {
            this._zone.value.setWidgetMargins(widgetPosition);
            this._zone.value.updatePositionAndHeight(widgetPosition);
        }
    }
    _resetWidget() {
        this._sessionStore.clear();
        this._ctxDidEdit.reset();
        this._ctxUserDidEdit.reset();
        this._ctxLastFeedbackKind.reset();
        this._ctxSupportIssueReporting.reset();
        this._zone.rawValue?.hide();
        if (this._editor.hasWidgetFocus()) {
            this._editor.focus();
        }
    }
    async _makeChanges(edits, opts) {
        assertType(this._session);
        assertType(this._strategy);
        const moreMinimalEdits = await this._editorWorkerService.computeMoreMinimalEdits(this._session.textModelN.uri, edits);
        this._log('edits from PROVIDER and after making them MORE MINIMAL', this._session.provider.debugName, edits, moreMinimalEdits);
        if (moreMinimalEdits?.length === 0) {
            return;
        }
        const actualEdits = !opts && moreMinimalEdits ? moreMinimalEdits : edits;
        const editOperations = ( actualEdits.map(TextEdit.asEditOperation));
        const editsObserver = {
            start: () => this._session.hunkData.ignoreTextModelNChanges = true,
            stop: () => this._session.hunkData.ignoreTextModelNChanges = false,
        };
        this._inlineChatSavingService.markChanged(this._session);
        this._session.wholeRange.trackEdits(editOperations);
        if (opts) {
            await this._strategy.makeProgressiveChanges(editOperations, editsObserver, opts);
        }
        else {
            await this._strategy.makeChanges(editOperations, editsObserver);
        }
        this._ctxDidEdit.set(this._session.hasChangedText);
    }
    _updatePlaceholder() {
        this._zone.value.widget.placeholder = this._getPlaceholderText();
    }
    _getPlaceholderText() {
        return this._forcedPlaceholder ?? this._session?.session.placeholder ?? '';
    }
    showSaveHint() {
        const status = ( localizeWithPath(
            'vs/workbench/contrib/inlineChat/browser/inlineChatController',
            'savehint',
            "Accept or discard changes to continue saving"
        ));
        this._zone.value.widget.updateStatus(status, { classes: ['warn'] });
    }
    setPlaceholder(text) {
        this._forcedPlaceholder = text;
        this._updatePlaceholder();
    }
    resetPlaceholder() {
        this._forcedPlaceholder = undefined;
        this._updatePlaceholder();
    }
    acceptInput() {
        this._messages.fire(32 );
    }
    updateInput(text, selectAll = true) {
        this._zone.value.widget.value = text;
        if (selectAll) {
            this._zone.value.widget.selectAll();
        }
    }
    getInput() {
        return this._zone.value.widget.value;
    }
    regenerate() {
        this._messages.fire(64 );
    }
    cancelCurrentRequest() {
        this._messages.fire(16  | 8 );
    }
    arrowOut(up) {
        if (this._zone.value.position && this._editor.hasModel()) {
            const { column } = this._editor.getPosition();
            const { lineNumber } = this._zone.value.position;
            const newLine = up ? lineNumber : lineNumber + 1;
            this._editor.setPosition({ lineNumber: newLine, column });
            this._editor.focus();
        }
    }
    focus() {
        this._zone.value.widget.focus();
    }
    hasFocus() {
        return this._zone.value.widget.hasFocus();
    }
    moveHunk(next) {
        this.focus();
        this._strategy?.move?.(next);
    }
    populateHistory(up) {
        const len = InlineChatController_1._promptHistory.length;
        if (len === 0) {
            return;
        }
        if (this._historyOffset === -1) {
            this._historyCandidate = this._zone.value.widget.value;
        }
        const newIdx = this._historyOffset + (up ? 1 : -1);
        if (newIdx >= len) {
            return;
        }
        let entry;
        if (newIdx < 0) {
            entry = this._historyCandidate;
            this._historyOffset = -1;
        }
        else {
            entry = InlineChatController_1._promptHistory[newIdx];
            this._historyOffset = newIdx;
        }
        this._zone.value.widget.value = entry;
        this._zone.value.widget.selectAll();
    }
    viewInChat() {
        if (this._session?.lastExchange?.response instanceof ReplyResponse) {
            this._instaService.invokeFunction(showMessageResponse, this._session.lastExchange.prompt.value, this._session.lastExchange.response.mdContent.value);
        }
    }
    updateExpansionState(expand) {
        if (this._session) {
            const expansionState = expand ? ExpansionState.EXPANDED : ExpansionState.CROPPED;
            this._zone.value.widget.updateChatMessageExpansionState(expansionState);
            this._session.lastExpansionState = expansionState;
        }
    }
    toggleDiff() {
        this._strategy?.toggleDiff?.();
    }
    feedbackLast(kind) {
        if (this._session?.lastExchange && this._session.lastExchange.response instanceof ReplyResponse) {
            this._session.provider.handleInlineChatResponseFeedback?.(this._session.session, this._session.lastExchange.response.raw, kind);
            switch (kind) {
                case 1 :
                    this._ctxLastFeedbackKind.set('helpful');
                    break;
                case 0 :
                    this._ctxLastFeedbackKind.set('unhelpful');
                    break;
            }
            this._zone.value.widget.updateStatus('Thank you for your feedback!', { resetAfter: 1250 });
        }
    }
    createSnapshot() {
        if (this._session && !this._session.textModel0.equalsTextBuffer(this._session.textModelN.getTextBuffer())) {
            this._session.createSnapshot();
        }
    }
    acceptSession() {
        if (this._session?.lastExchange && this._session.lastExchange.response instanceof ReplyResponse) {
            this._session.provider.handleInlineChatResponseFeedback?.(this._session.session, this._session.lastExchange.response.raw, 3 );
        }
        this._messages.fire(1 );
    }
    acceptHunk() {
        return this._strategy?.acceptHunk();
    }
    discardHunk() {
        return this._strategy?.discardHunk();
    }
    async cancelSession() {
        let result;
        if (this._session) {
            const diff = await this._editorWorkerService.computeDiff(this._session.textModel0.uri, this._session.textModelN.uri, { ignoreTrimWhitespace: false, maxComputationTimeMs: 5000, computeMoves: false }, 'advanced');
            result = this._session.asChangedText(diff?.changes ?? []);
            if (this._session.lastExchange && this._session.lastExchange.response instanceof ReplyResponse) {
                this._session.provider.handleInlineChatResponseFeedback?.(this._session.session, this._session.lastExchange.response.raw, 2 );
            }
        }
        this._messages.fire(2 );
        return result;
    }
    finishExistingSession() {
        if (this._session) {
            if (this._session.editMode === "preview" ) {
                this._log('finishing existing session, using CANCEL', this._session.editMode);
                this.cancelSession();
            }
            else {
                this._log('finishing existing session, using APPLY', this._session.editMode);
                this.acceptSession();
            }
        }
    }
    unstashLastSession() {
        const result = this._stashedSession.value?.unstash();
        if (result) {
            this._inlineChatSavingService.markChanged(result);
        }
        return result;
    }
    joinCurrentRun() {
        return this._currentRun;
    }
};
InlineChatController = InlineChatController_1 = ( __decorate([
    ( __param(1, IInstantiationService)),
    ( __param(2, IInlineChatSessionService)),
    ( __param(3, IInlineChatSavingService)),
    ( __param(4, IEditorWorkerService)),
    ( __param(5, ILogService)),
    ( __param(6, IConfigurationService)),
    ( __param(7, IDialogService)),
    ( __param(8, IContextKeyService)),
    ( __param(9, IChatAccessibilityService)),
    ( __param(10, IChatAgentService)),
    ( __param(11, IBulkEditService)),
    ( __param(12, IStorageService)),
    ( __param(13, ICommandService))
], InlineChatController));
async function showMessageResponse(accessor, query, response) {
    const chatService = accessor.get(IChatService);
    const providerId = chatService.getProviderInfos()[0]?.id;
    const chatWidgetService = accessor.get(IChatWidgetService);
    const widget = await chatWidgetService.revealViewForProvider(providerId);
    if (widget && widget.viewModel) {
        chatService.addCompleteRequest(widget.viewModel.sessionId, query, undefined, { message: response });
        widget.focusLastMessage();
    }
}
async function sendRequest(accessor, query) {
    const chatService = accessor.get(IChatService);
    const widgetService = accessor.get(IChatWidgetService);
    const providerId = chatService.getProviderInfos()[0]?.id;
    const widget = await widgetService.revealViewForProvider(providerId);
    if (!widget) {
        return;
    }
    widget.acceptInput(query);
}
export { InlineChatController, InlineChatRunOptions };
