import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { Emitter } from '../../../../base/common/event.js';
import { Disposable } from '../../../../base/common/lifecycle.js';
import { deepClone } from '../../../../base/common/objects.js';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';
import { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';
import { IStorageService } from '../../../../platform/storage/common/storage.js';
import { StoredValue } from './storedValue.js';
import { TestId } from './testId.js';
import { testRunProfileBitsetList } from './testTypes.js';
import { TestingContextKeys } from './testingContextKeys.js';
const ITestProfileService = ( createDecorator('testProfileService'));
const canUseProfileWithTest = (profile, test) => profile.controllerId === test.controllerId && (TestId.isRoot(test.item.extId) || !profile.tag || test.item.tags.includes(profile.tag));
const sorter = (a, b) => {
    if (a.isDefault !== b.isDefault) {
        return a.isDefault ? -1 : 1;
    }
    return a.label.localeCompare(b.label);
};
const capabilityContextKeys = (capabilities) => [
    [TestingContextKeys.hasRunnableTests.key, ((capabilities & 2) ) !== 0],
    [TestingContextKeys.hasDebuggableTests.key, ((capabilities & 4) ) !== 0],
    [TestingContextKeys.hasCoverableTests.key, ((capabilities & 8) ) !== 0],
];
let TestProfileService = class TestProfileService extends Disposable {
    constructor(contextKeyService, storageService) {
        super();
        this.changeEmitter = this._register(( new Emitter()));
        this.controllerProfiles = ( new Map());
        this.onDidChange = this.changeEmitter.event;
        storageService.remove('testingPreferredProfiles', 1 );
        this.userDefaults = this._register(( new StoredValue({
            key: 'testingPreferredProfiles2',
            scope: 1 ,
            target: 1 ,
        }, storageService)));
        this.capabilitiesContexts = {
            [2 ]: TestingContextKeys.hasRunnableTests.bindTo(contextKeyService),
            [4 ]: TestingContextKeys.hasDebuggableTests.bindTo(contextKeyService),
            [8 ]: TestingContextKeys.hasCoverableTests.bindTo(contextKeyService),
            [16 ]: TestingContextKeys.hasNonDefaultProfile.bindTo(contextKeyService),
            [32 ]: TestingContextKeys.hasConfigurableProfile.bindTo(contextKeyService),
            [64 ]: TestingContextKeys.supportsContinuousRun.bindTo(contextKeyService),
        };
        this.refreshContextKeys();
    }
    addProfile(controller, profile) {
        const previousExplicitDefaultValue = this.userDefaults.get()?.[controller.id]?.[profile.profileId];
        const extended = {
            ...profile,
            isDefault: previousExplicitDefaultValue ?? profile.isDefault,
            wasInitiallyDefault: profile.isDefault,
        };
        let record = this.controllerProfiles.get(profile.controllerId);
        if (record) {
            record.profiles.push(extended);
            record.profiles.sort(sorter);
        }
        else {
            record = {
                profiles: [extended],
                controller,
            };
            this.controllerProfiles.set(profile.controllerId, record);
        }
        this.refreshContextKeys();
        this.changeEmitter.fire();
    }
    updateProfile(controllerId, profileId, update) {
        const ctrl = this.controllerProfiles.get(controllerId);
        if (!ctrl) {
            return;
        }
        const profile = ctrl.profiles.find(c => c.controllerId === controllerId && c.profileId === profileId);
        if (!profile) {
            return;
        }
        Object.assign(profile, update);
        ctrl.profiles.sort(sorter);
        if (update.isDefault !== undefined) {
            const map = deepClone(this.userDefaults.get({}));
            setIsDefault(map, profile, update.isDefault);
            this.userDefaults.store(map);
        }
        this.changeEmitter.fire();
    }
    configure(controllerId, profileId) {
        this.controllerProfiles.get(controllerId)?.controller.configureRunProfile(profileId);
    }
    removeProfile(controllerId, profileId) {
        const ctrl = this.controllerProfiles.get(controllerId);
        if (!ctrl) {
            return;
        }
        if (!profileId) {
            this.controllerProfiles.delete(controllerId);
            this.changeEmitter.fire();
            return;
        }
        const index = ctrl.profiles.findIndex(c => c.profileId === profileId);
        if (index === -1) {
            return;
        }
        ctrl.profiles.splice(index, 1);
        this.refreshContextKeys();
        this.changeEmitter.fire();
    }
    capabilitiesForTest(test) {
        const ctrl = this.controllerProfiles.get(test.controllerId);
        if (!ctrl) {
            return 0;
        }
        let capabilities = 0;
        for (const profile of ctrl.profiles) {
            if (!profile.tag || test.item.tags.includes(profile.tag)) {
                capabilities |= capabilities & profile.group ? 16  : profile.group;
            }
        }
        return capabilities;
    }
    all() {
        return ( this.controllerProfiles.values());
    }
    getControllerProfiles(profileId) {
        return this.controllerProfiles.get(profileId)?.profiles ?? [];
    }
    getGroupDefaultProfiles(group) {
        let defaults = [];
        for (const { profiles } of ( this.controllerProfiles.values())) {
            defaults = defaults.concat(profiles.filter(c => c.group === group && c.isDefault));
        }
        if (defaults.length === 0) {
            for (const { profiles } of ( this.controllerProfiles.values())) {
                const first = profiles.find(p => p.group === group);
                if (first) {
                    defaults.push(first);
                    break;
                }
            }
        }
        return defaults;
    }
    setGroupDefaultProfiles(group, profiles) {
        const next = {};
        for (const ctrl of ( this.controllerProfiles.values())) {
            next[ctrl.controller.id] = {};
            for (const profile of ctrl.profiles) {
                if (profile.group !== group) {
                    continue;
                }
                setIsDefault(next, profile, ( profiles.some(p => p.profileId === profile.profileId)));
            }
            for (const profile of ctrl.profiles) {
                if (profile.group === group) {
                    continue;
                }
                const matching = ctrl.profiles.find(p => p.group === group && p.label === profile.label);
                if (matching) {
                    setIsDefault(next, profile, matching.isDefault);
                }
            }
            ctrl.profiles.sort(sorter);
        }
        this.userDefaults.store(next);
        this.changeEmitter.fire();
    }
    refreshContextKeys() {
        let allCapabilities = 0;
        for (const { profiles } of ( this.controllerProfiles.values())) {
            for (const profile of profiles) {
                allCapabilities |= allCapabilities & profile.group ? 16  : profile.group;
                allCapabilities |= profile.supportsContinuousRun ? 64  : 0;
            }
        }
        for (const group of testRunProfileBitsetList) {
            this.capabilitiesContexts[group].set((allCapabilities & group) !== 0);
        }
    }
};
TestProfileService = ( __decorate([
    ( __param(0, IContextKeyService)),
    ( __param(1, IStorageService))
], TestProfileService));
const setIsDefault = (map, profile, isDefault) => {
    profile.isDefault = isDefault;
    map[profile.controllerId] ??= {};
    if (profile.isDefault !== profile.wasInitiallyDefault) {
        map[profile.controllerId][profile.profileId] = profile.isDefault;
    }
    else {
        delete map[profile.controllerId][profile.profileId];
    }
};
export { ITestProfileService, TestProfileService, canUseProfileWithTest, capabilityContextKeys };
