import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { CancellationTokenSource } from '../../../../base/common/cancellation.js';
import { Disposable, MutableDisposable } from '../../../../base/common/lifecycle.js';
import { localizeWithPath } from '../../../../nls.js';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';
import { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';
import { INotificationService } from '../../../../platform/notification/common/notification.js';
import { IViewsService } from '../../../services/views/common/viewsService.js';
import { ITestResultService } from './testResultService.js';
import { TestingContextKeys } from './testingContextKeys.js';
import { observableValue } from '../../../../base/common/observableInternal/base.js';
const ITestCoverageService = ( createDecorator('testCoverageService'));
let TestCoverageService = class TestCoverageService extends Disposable {
    constructor(contextKeyService, resultService, viewsService, notificationService) {
        super();
        this.viewsService = viewsService;
        this.notificationService = notificationService;
        this.lastOpenCts = this._register(( new MutableDisposable()));
        this.selected = observableValue('testCoverage', undefined);
        this._isOpenKey = TestingContextKeys.isTestCoverageOpen.bindTo(contextKeyService);
        this._register(resultService.onResultsChanged(evt => {
            if ('completed' in evt) {
                const coverage = evt.completed.tasks.find(t => t.coverage.get());
                if (coverage) {
                    this.openCoverage(coverage, false);
                }
                else {
                    this.closeCoverage();
                }
            }
            else if ('removed' in evt && this.selected.get()) {
                const taskId = this.selected.get()?.fromTaskId;
                if (( evt.removed.some(e => ( e.tasks.some(t => t.id === taskId))))) {
                    this.closeCoverage();
                }
            }
        }));
    }
    async openCoverage(task, focus = true) {
        this.lastOpenCts.value?.cancel();
        const cts = this.lastOpenCts.value = ( new CancellationTokenSource());
        const getCoverage = task.coverage.get();
        if (!getCoverage) {
            return;
        }
        try {
            const coverage = await getCoverage(cts.token);
            this.selected.set(coverage, undefined);
            this._isOpenKey.set(true);
        }
        catch (e) {
            if (!cts.token.isCancellationRequested) {
                this.notificationService.error(( localizeWithPath(
                    'vs/workbench/contrib/testing/common/testCoverageService',
                    'testCoverageError',
                    'Failed to load test coverage: {0}',
                    String(e)
                )));
            }
            return;
        }
        if (focus && !cts.token.isCancellationRequested) {
            this.viewsService.openView("workbench.view.testCoverage" , true);
        }
    }
    closeCoverage() {
        this._isOpenKey.set(false);
        this.selected.set(undefined, undefined);
    }
};
TestCoverageService = ( __decorate([
    ( __param(0, IContextKeyService)),
    ( __param(1, ITestResultService)),
    ( __param(2, IViewsService)),
    ( __param(3, INotificationService))
], TestCoverageService));
export { ITestCoverageService, TestCoverageService };
