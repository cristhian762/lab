import { CancellationToken } from '../../../../base/common/cancellation.js';
import { ResourceMap } from '../../../../base/common/map.js';
import { WellDefinedPrefixTree } from '../../../../base/common/prefixTree.js';
import { URI } from '../../../../base/common/uri.js';
import { ICoveredCount } from './testTypes.js';
class TestCoverage {
    static async load(taskId, accessor, uriIdentityService, token) {
        const files = await accessor.provideFileCoverage(token);
        const map = ( new ResourceMap());
        for (const [i, file] of files.entries()) {
            map.set(file.uri, ( new FileCoverage(file, i, accessor)));
        }
        return ( new TestCoverage(taskId, map, uriIdentityService));
    }
    get tree() {
        return this._tree ??= this.buildCoverageTree();
    }
    constructor(fromTaskId, fileCoverage, uriIdentityService) {
        this.fromTaskId = fromTaskId;
        this.fileCoverage = fileCoverage;
        this.uriIdentityService = uriIdentityService;
        this.associatedData = ( new Map());
    }
    getAllFiles() {
        return this.fileCoverage;
    }
    getUri(uri) {
        return this.fileCoverage.get(uri);
    }
    getComputedForUri(uri) {
        return this.tree.find(this.treePathForUri(uri,  false));
    }
    buildCoverageTree() {
        const tree = ( new WellDefinedPrefixTree());
        const nodeCanonicalSegments = ( new Map());
        for (const file of ( this.fileCoverage.values())) {
            const keyPath = this.treePathForUri(file.uri,  false);
            const canonicalPath = this.treePathForUri(file.uri,  true);
            tree.insert(keyPath, file, node => {
                nodeCanonicalSegments.set(node, canonicalPath.next().value);
            });
        }
        const calculateComputed = (path, node) => {
            if (node.value) {
                return node.value;
            }
            const fileCoverage = {
                uri: this.treePathToUri(path),
                statement: ICoveredCount.empty(),
            };
            if (node.children) {
                for (const [prefix, child] of node.children) {
                    path.push(nodeCanonicalSegments.get(child) || prefix);
                    const v = calculateComputed(path, child);
                    path.pop();
                    ICoveredCount.sum(fileCoverage.statement, v.statement);
                    if (v.branch) {
                        ICoveredCount.sum(fileCoverage.branch ??= ICoveredCount.empty(), v.branch);
                    }
                    if (v.declaration) {
                        ICoveredCount.sum(fileCoverage.declaration ??= ICoveredCount.empty(), v.declaration);
                    }
                }
            }
            return node.value = ( new ComputedFileCoverage(fileCoverage));
        };
        for (const node of tree.nodes) {
            calculateComputed([], node);
        }
        return tree;
    }
    *treePathForUri(uri, canconicalPath) {
        yield uri.scheme;
        yield uri.authority;
        const path = !canconicalPath && this.uriIdentityService.extUri.ignorePathCasing(uri) ? uri.path.toLowerCase() : uri.path;
        yield* path.split('/');
    }
    treePathToUri(path) {
        return ( URI.from({ scheme: path[0], authority: path[1], path: path.slice(2).join('/') }));
    }
}
const getTotalCoveragePercent = (statement, branch, function_) => {
    let numerator = statement.covered;
    let denominator = statement.total;
    if (branch) {
        numerator += branch.covered;
        denominator += branch.total;
    }
    if (function_) {
        numerator += function_.covered;
        denominator += function_.total;
    }
    return denominator === 0 ? 1 : numerator / denominator;
};
class AbstractFileCoverage {
    get tpc() {
        return getTotalCoveragePercent(this.statement, this.branch, this.declaration);
    }
    constructor(coverage) {
        this.uri = coverage.uri;
        this.statement = coverage.statement;
        this.branch = coverage.branch;
        this.declaration = coverage.declaration;
    }
}
class ComputedFileCoverage extends AbstractFileCoverage {
}
class FileCoverage extends AbstractFileCoverage {
    get hasSynchronousDetails() {
        return this._details instanceof Array || this.resolved;
    }
    constructor(coverage, index, accessor) {
        super(coverage);
        this.index = index;
        this.accessor = accessor;
        this._details = coverage.details;
    }
    async details(token = CancellationToken.None) {
        this._details ??= this.accessor.resolveFileCoverage(this.index, token);
        try {
            const d = await this._details;
            this.resolved = true;
            return d;
        }
        catch (e) {
            this._details = undefined;
            throw e;
        }
    }
}
export { AbstractFileCoverage, ComputedFileCoverage, FileCoverage, TestCoverage, getTotalCoveragePercent };
