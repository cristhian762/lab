import { CancellationToken } from '../../../../base/common/cancellation.js';
import { Iterable } from '../../../../base/common/iterator.js';
import { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';
import { TestId } from './testId.js';
const ITestService = ( createDecorator('testService'));
const testCollectionIsEmpty = (collection) => !( Iterable.some(collection.rootItems, r => r.children.size > 0));
const getContextForTestItem = (collection, id) => {
    if (typeof id === 'string') {
        id = TestId.fromString(id);
    }
    if (id.isRoot) {
        return { controller: ( id.toString()) };
    }
    const context = { $mid: 16 , tests: [] };
    for (const i of id.idsFromRoot()) {
        if (!i.isRoot) {
            const test = collection.getNodeById(( i.toString()));
            if (test) {
                context.tests.push(test);
            }
        }
    }
    return context;
};
const expandAndGetTestById = async (collection, id, ct = CancellationToken.None) => {
    const idPath = [...TestId.fromString(id).idsFromRoot()];
    let expandToLevel = 0;
    for (let i = idPath.length - 1; !ct.isCancellationRequested && i >= expandToLevel;) {
        const id = ( idPath[i].toString());
        const existing = collection.getNodeById(id);
        if (!existing) {
            i--;
            continue;
        }
        if (i === idPath.length - 1) {
            return existing;
        }
        if (!( existing.children.has(( idPath[i + 1].toString())))) {
            await collection.expand(id, 0);
        }
        expandToLevel = i + 1;
        i = idPath.length - 1;
    }
    return undefined;
};
const waitForTestToBeIdle = (testService, test) => {
    if (!test.item.busy) {
        return;
    }
    return ( new Promise(resolve => {
        const l = testService.onDidProcessDiff(() => {
            if (testService.collection.getNodeById(test.item.extId)?.item.busy !== true) {
                resolve();
                l.dispose();
            }
        });
    }));
};
const testsInFile = async function* (testService, ident, uri, waitForIdle = true) {
    for (const test of testService.collection.all) {
        if (!test.item.uri) {
            continue;
        }
        if (ident.extUri.isEqual(uri, test.item.uri)) {
            yield test;
        }
        if (ident.extUri.isEqualOrParent(uri, test.item.uri)) {
            if (test.expand === 1 ) {
                await testService.collection.expand(test.item.extId, 1);
            }
            if (waitForIdle) {
                await waitForTestToBeIdle(testService, test);
            }
        }
    }
};
const testsUnderUri = async function* (testService, ident, uri, waitForIdle = true) {
    const queue = [testService.collection.rootIds];
    while (queue.length) {
        for (const testId of queue.pop()) {
            const test = testService.collection.getNodeById(testId);
            if (!test) ;
            else if (!test.item.uri) {
                queue.push(( test.children.values()));
                continue;
            }
            else if (ident.extUri.isEqualOrParent(uri, test.item.uri)) {
                if (test.expand === 1 ) {
                    await testService.collection.expand(test.item.extId, 1);
                }
                if (waitForIdle) {
                    await waitForTestToBeIdle(testService, test);
                }
                queue.push(( test.children.values()));
            }
            else if (ident.extUri.isEqualOrParent(test.item.uri, uri)) {
                yield test;
            }
        }
    }
};
export { ITestService, expandAndGetTestById, getContextForTestItem, testCollectionIsEmpty, testsInFile, testsUnderUri };
