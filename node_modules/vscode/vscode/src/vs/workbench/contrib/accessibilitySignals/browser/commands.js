import { Codicon } from '../../../../base/common/codicons.js';
import { ThemeIcon } from '../../../../base/common/themables.js';
import { localize2WithPath, localizeWithPath } from '../../../../nls.js';
import { IAccessibilityService } from '../../../../platform/accessibility/common/accessibility.js';
import { Action2 } from '../../../../platform/actions/common/actions.js';
import { IAccessibilitySignalService, AccessibilitySignal } from '../../../../platform/accessibilitySignal/browser/accessibilitySignalService.js';
import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';
import { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';
import { IPreferencesService } from '../../../services/preferences/common/preferences.js';
class ShowSignalSoundHelp extends Action2 {
    static { this.ID = 'signals.sounds.help'; }
    constructor() {
        super({
            id: ShowSignalSoundHelp.ID,
            title: ( localize2WithPath(
                'vs/workbench/contrib/accessibilitySignals/browser/commands',
                'signals.sound.help',
                "Help: List Signal Sounds"
            )),
            f1: true,
            metadata: {
                description: ( localizeWithPath(
                    'vs/workbench/contrib/accessibilitySignals/browser/commands',
                    'accessibility.sound.help.description',
                    "List all accessibility sounds / audio cues and configure their settings"
                ))
            }
        });
    }
    async run(accessor) {
        const accessibilitySignalService = accessor.get(IAccessibilitySignalService);
        const quickInputService = accessor.get(IQuickInputService);
        const configurationService = accessor.get(IConfigurationService);
        const accessibilityService = accessor.get(IAccessibilityService);
        const preferencesService = accessor.get(IPreferencesService);
        const userGestureSignals = [AccessibilitySignal.save, AccessibilitySignal.format];
        const items = ( AccessibilitySignal.allAccessibilitySignals.map((signal, idx) => ({
            label: userGestureSignals.includes(signal) ? `${signal.name} (${configurationService.getValue(signal.settingsKey + '.sound')})` : signal.name,
            signal,
            buttons: userGestureSignals.includes(signal) ? [{
                    iconClass: ThemeIcon.asClassName(Codicon.settingsGear),
                    tooltip: ( localizeWithPath(
                        'vs/workbench/contrib/accessibilitySignals/browser/commands',
                        'sounds.help.settings',
                        'Configure Sound'
                    )),
                    alwaysVisible: true
                }] : []
        })));
        const qp = quickInputService.createQuickPick();
        qp.items = items;
        qp.selectedItems = items.filter(i => accessibilitySignalService.isSoundEnabled(i.signal) || userGestureSignals.includes(i.signal) && configurationService.getValue(i.signal.settingsKey + '.sound') !== 'never');
        qp.onDidAccept(() => {
            const enabledSounds = ( qp.selectedItems.map(i => i.signal));
            const disabledSounds = ( qp.items.map(i => i.signal)).filter(i => !enabledSounds.includes(i));
            for (const signal of enabledSounds) {
                let { sound, announcement } = configurationService.getValue(signal.settingsKey);
                sound = userGestureSignals.includes(signal) ? 'userGesture' : accessibilityService.isScreenReaderOptimized() ? 'auto' : 'on';
                if (announcement) {
                    configurationService.updateValue(signal.settingsKey, { sound, announcement });
                }
                else {
                    configurationService.updateValue(signal.settingsKey, { sound });
                }
            }
            for (const signal of disabledSounds) {
                let { sound, announcement } = configurationService.getValue(signal.settingsKey);
                sound = userGestureSignals.includes(signal) ? 'never' : 'off';
                if (announcement) {
                    configurationService.updateValue(signal.settingsKey, { sound, announcement });
                }
                else {
                    configurationService.updateValue(signal.settingsKey, { sound });
                }
            }
            qp.hide();
        });
        qp.onDidTriggerItemButton(e => {
            preferencesService.openUserSettings({ jsonEditor: true, revealSetting: { key: e.item.signal.settingsKey, edit: true } });
        });
        qp.onDidChangeActive(() => {
            accessibilitySignalService.playSound(qp.activeItems[0].signal.sound.getSound(true), true);
        });
        qp.placeholder = ( localizeWithPath(
            'vs/workbench/contrib/accessibilitySignals/browser/commands',
            'audioCues.help.placeholder',
            'Select a sound to play and configure'
        ));
        qp.canSelectMany = true;
        await qp.show();
    }
}
class ShowAccessibilityAnnouncementHelp extends Action2 {
    static { this.ID = 'accessibility.announcement.help'; }
    constructor() {
        super({
            id: ShowAccessibilityAnnouncementHelp.ID,
            title: ( localize2WithPath(
                'vs/workbench/contrib/accessibilitySignals/browser/commands',
                'accessibility.announcement.help',
                "Help: List Signal Announcements"
            )),
            f1: true,
            metadata: {
                description: ( localizeWithPath(
                    'vs/workbench/contrib/accessibilitySignals/browser/commands',
                    'accessibility.announcement.help.description',
                    "List all accessibility announcements / alerts and configure their settings"
                ))
            }
        });
    }
    async run(accessor) {
        const accessibilitySignalService = accessor.get(IAccessibilitySignalService);
        const quickInputService = accessor.get(IQuickInputService);
        const configurationService = accessor.get(IConfigurationService);
        const accessibilityService = accessor.get(IAccessibilityService);
        const preferencesService = accessor.get(IPreferencesService);
        const userGestureSignals = [AccessibilitySignal.save, AccessibilitySignal.format];
        const items = ( AccessibilitySignal.allAccessibilitySignals.filter(c => !!c.legacyAnnouncementSettingsKey).map((signal, idx) => ({
            label: userGestureSignals.includes(signal) ? `${signal.name} (${configurationService.getValue(signal.settingsKey + '.announcement')})` : signal.name,
            signal,
            buttons: userGestureSignals.includes(signal) ? [{
                    iconClass: ThemeIcon.asClassName(Codicon.settingsGear),
                    tooltip: ( localizeWithPath(
                        'vs/workbench/contrib/accessibilitySignals/browser/commands',
                        'announcement.help.settings',
                        'Configure Announcement'
                    )),
                    alwaysVisible: true,
                }] : []
        })));
        const qp = quickInputService.createQuickPick();
        qp.items = items;
        qp.selectedItems = items.filter(i => accessibilitySignalService.isAnnouncementEnabled(i.signal) || userGestureSignals.includes(i.signal) && configurationService.getValue(i.signal.settingsKey + '.announcement') !== 'never');
        qp.onDidAccept(() => {
            const enabledAnnouncements = ( qp.selectedItems.map(i => i.signal));
            const disabledAnnouncements = AccessibilitySignal.allAccessibilitySignals.filter(cue => !!cue.legacyAnnouncementSettingsKey && !enabledAnnouncements.includes(cue));
            for (const signal of enabledAnnouncements) {
                let { sound, announcement } = configurationService.getValue(signal.settingsKey);
                announcement = userGestureSignals.includes(signal) ? 'userGesture' : signal.announcementMessage && accessibilityService.isScreenReaderOptimized() ? 'auto' : undefined;
                configurationService.updateValue(signal.settingsKey, { sound, announcement });
            }
            for (const signal of disabledAnnouncements) {
                const announcement = userGestureSignals.includes(signal) ? 'never' : 'off';
                const sound = configurationService.getValue(signal.settingsKey + '.sound');
                configurationService.updateValue(signal.settingsKey, announcement ? { sound, announcement } : { sound });
            }
            qp.hide();
        });
        qp.onDidTriggerItemButton(e => {
            preferencesService.openUserSettings({ jsonEditor: true, revealSetting: { key: e.item.signal.settingsKey, edit: true } });
        });
        qp.placeholder = ( localizeWithPath(
            'vs/workbench/contrib/accessibilitySignals/browser/commands',
            'announcement.help.placeholder',
            'Select an announcement to configure'
        ));
        qp.canSelectMany = true;
        await qp.show();
    }
}
export { ShowAccessibilityAnnouncementHelp, ShowSignalSoundHelp };
