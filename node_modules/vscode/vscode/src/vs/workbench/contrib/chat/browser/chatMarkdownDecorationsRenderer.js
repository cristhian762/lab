import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { $ } from '../../../../base/browser/dom.js';
import { toErrorMessage } from '../../../../base/common/errorMessage.js';
import { MarkdownString } from '../../../../base/common/htmlContent.js';
import { revive } from '../../../../base/common/marshalling.js';
import { basename } from '../../../../base/common/resources.js';
import { URI } from '../../../../base/common/uri.js';
import { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';
import { ILabelService } from '../../../../platform/label/common/label.js';
import { ILogService } from '../../../../platform/log/common/log.js';
import { ChatRequestTextPart, ChatRequestDynamicVariablePart } from '../common/chatParserTypes.js';
const variableRefUrl = 'http://_vscodedecoration_';
let ChatMarkdownDecorationsRenderer = class ChatMarkdownDecorationsRenderer {
    constructor(keybindingService, labelService, logService) {
        this.keybindingService = keybindingService;
        this.labelService = labelService;
        this.logService = logService;
    }
    convertParsedRequestToMarkdown(parsedRequest) {
        let result = '';
        for (const part of parsedRequest.parts) {
            if (part instanceof ChatRequestTextPart) {
                result += part.text;
            }
            else {
                const uri = part instanceof ChatRequestDynamicVariablePart && ( part.data.map(d => d.value)).find((d) => d instanceof URI)
                    || undefined;
                const title = uri ? encodeURIComponent(this.labelService.getUriLabel(uri, { relative: true })) : '';
                result += `[${part.text}](${variableRefUrl}?${title})`;
            }
        }
        return result;
    }
    walkTreeAndAnnotateReferenceLinks(element) {
        element.querySelectorAll('a').forEach(a => {
            const href = a.getAttribute('data-href');
            if (href) {
                if (href.startsWith(variableRefUrl)) {
                    const title = decodeURIComponent(href.slice(variableRefUrl.length + 1));
                    a.parentElement.replaceChild(this.renderResourceWidget(a.textContent, title), a);
                }
                else if (href.startsWith(contentRefUrl)) {
                    this.renderFileWidget(href, a);
                }
                else if (href.startsWith('command:')) {
                    this.injectKeybindingHint(a, href, this.keybindingService);
                }
            }
        });
    }
    renderFileWidget(href, a) {
        const fullUri = ( URI.parse(href));
        let location;
        try {
            location = revive(JSON.parse(fullUri.fragment));
        }
        catch (err) {
            this.logService.error('Invalid chat widget render data JSON', toErrorMessage(err));
            return;
        }
        if (!location.uri || !URI.isUri(location.uri)) {
            this.logService.error(`Invalid chat widget render data: ${fullUri.fragment}`);
            return;
        }
        const fragment = location.range ? `${location.range.startLineNumber}-${location.range.endLineNumber}` : '';
        a.setAttribute('data-href', ( location.uri.with({ fragment }).toString()));
        const label = this.labelService.getUriLabel(location.uri, { relative: true });
        a.title = location.range ?
            `${label}#${location.range.startLineNumber}-${location.range.endLineNumber}` :
            label;
    }
    renderResourceWidget(name, title) {
        const container = $('span.chat-resource-widget');
        const alias = $('span', undefined, name);
        alias.title = title;
        container.appendChild(alias);
        return container;
    }
    injectKeybindingHint(a, href, keybindingService) {
        const command = href.match(/command:([^\)]+)/)?.[1];
        if (command) {
            const kb = keybindingService.lookupKeybinding(command);
            if (kb) {
                const keybinding = kb.getLabel();
                if (keybinding) {
                    a.textContent = `${a.textContent} (${keybinding})`;
                }
            }
        }
    }
};
ChatMarkdownDecorationsRenderer = ( __decorate([
    ( __param(0, IKeybindingService)),
    ( __param(1, ILabelService)),
    ( __param(2, ILogService))
], ChatMarkdownDecorationsRenderer));
function extractVulnerabilitiesFromText(text) {
    const vulnerabilities = [];
    let newText = text;
    let match;
    while ((match = /<vscode_annotation details="(.*?)">(.*?)<\/vscode_annotation>/ms.exec(newText)) !== null) {
        const [full, details, content] = match;
        const start = match.index;
        const textBefore = newText.substring(0, start);
        const linesBefore = textBefore.split('\n').length - 1;
        const linesInside = content.split('\n').length - 1;
        const previousNewlineIdx = textBefore.lastIndexOf('\n');
        const startColumn = start - (previousNewlineIdx + 1) + 1;
        const endPreviousNewlineIdx = (textBefore + content).lastIndexOf('\n');
        const endColumn = start + content.length - (endPreviousNewlineIdx + 1) + 1;
        try {
            const vulnDetails = JSON.parse(decodeURIComponent(details));
            vulnDetails.forEach(({ title, description }) => vulnerabilities.push({
                title, description, range: { startLineNumber: linesBefore + 1, startColumn, endLineNumber: linesBefore + linesInside + 1, endColumn }
            }));
        }
        catch (err) {
        }
        newText = newText.substring(0, start) + content + newText.substring(start + full.length);
    }
    return { newText, vulnerabilities };
}
const contentRefUrl = 'http://_vscodecontentref_';
function annotateSpecialMarkdownContent(response) {
    const result = [];
    for (const item of response) {
        const previousItem = result[result.length - 1];
        if (item.kind === 'inlineReference') {
            const location = 'uri' in item.inlineReference ? item.inlineReference : { uri: item.inlineReference };
            const printUri = ( URI.parse(contentRefUrl)).with({ fragment: JSON.stringify(location) });
            const markdownText = `[${item.name || basename(location.uri)}](${( printUri.toString())})`;
            if (previousItem?.kind === 'markdownContent') {
                result[result.length - 1] = { content: ( new MarkdownString(
                    previousItem.content.value + markdownText,
                    { isTrusted: previousItem.content.isTrusted }
                )), kind: 'markdownContent' };
            }
            else {
                result.push({ content: ( new MarkdownString(markdownText)), kind: 'markdownContent' });
            }
        }
        else if (item.kind === 'markdownContent' && previousItem?.kind === 'markdownContent') {
            result[result.length - 1] = { content: ( new MarkdownString(
                previousItem.content.value + item.content.value,
                { isTrusted: previousItem.content.isTrusted }
            )), kind: 'markdownContent' };
        }
        else if (item.kind === 'markdownVuln') {
            const vulnText = encodeURIComponent(JSON.stringify(item.vulnerabilities));
            const markdownText = `<vscode_annotation details="${vulnText}">${item.content.value}</vscode_annotation>`;
            if (previousItem?.kind === 'markdownContent') {
                result[result.length - 1] = { content: ( new MarkdownString(
                    previousItem.content.value + markdownText,
                    { isTrusted: previousItem.content.isTrusted }
                )), kind: 'markdownContent' };
            }
            else {
                result.push({ content: ( new MarkdownString(markdownText)), kind: 'markdownContent' });
            }
        }
        else {
            result.push(item);
        }
    }
    return result;
}
export { ChatMarkdownDecorationsRenderer, annotateSpecialMarkdownContent, extractVulnerabilitiesFromText };
