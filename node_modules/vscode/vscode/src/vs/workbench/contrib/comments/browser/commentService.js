import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { createDecorator, IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
import { Emitter, Event } from '../../../../base/common/event.js';
import { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';
import { Range } from '../../../../editor/common/core/range.js';
import { CancellationToken } from '../../../../base/common/cancellation.js';
import { CommentMenus } from './commentMenus.js';
import { IWorkbenchLayoutService } from '../../../services/layout/browser/layoutService.js';
import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';
import { COMMENTS_SECTION } from '../common/commentsConfiguration.js';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';
import { IStorageService } from '../../../../platform/storage/common/storage.js';
import { CommentContextKeys } from '../common/commentContextKeys.js';
import { ILogService } from '../../../../platform/log/common/log.js';
import { CommentsModel } from './commentsModel.js';
const ICommentService = ( createDecorator('commentService'));
const CONTINUE_ON_COMMENTS = 'comments.continueOnComments';
let CommentService = class CommentService extends Disposable {
    constructor(instantiationService, layoutService, configurationService, contextKeyService, storageService, logService) {
        super();
        this.instantiationService = instantiationService;
        this.layoutService = layoutService;
        this.configurationService = configurationService;
        this.storageService = storageService;
        this.logService = logService;
        this._onDidSetDataProvider = this._register(( new Emitter()));
        this.onDidSetDataProvider = this._onDidSetDataProvider.event;
        this._onDidDeleteDataProvider = this._register(( new Emitter()));
        this.onDidDeleteDataProvider = this._onDidDeleteDataProvider.event;
        this._onDidSetResourceCommentInfos = this._register(( new Emitter()));
        this.onDidSetResourceCommentInfos = this._onDidSetResourceCommentInfos.event;
        this._onDidSetAllCommentThreads = this._register(( new Emitter()));
        this.onDidSetAllCommentThreads = this._onDidSetAllCommentThreads.event;
        this._onDidUpdateCommentThreads = this._register(( new Emitter()));
        this.onDidUpdateCommentThreads = this._onDidUpdateCommentThreads.event;
        this._onDidUpdateNotebookCommentThreads = this._register(( new Emitter()));
        this.onDidUpdateNotebookCommentThreads = this._onDidUpdateNotebookCommentThreads.event;
        this._onDidUpdateCommentingRanges = this._register(( new Emitter()));
        this.onDidUpdateCommentingRanges = this._onDidUpdateCommentingRanges.event;
        this._onDidChangeActiveEditingCommentThread = this._register(( new Emitter()));
        this.onDidChangeActiveEditingCommentThread = this._onDidChangeActiveEditingCommentThread.event;
        this._onDidChangeCurrentCommentThread = this._register(( new Emitter()));
        this.onDidChangeCurrentCommentThread = this._onDidChangeCurrentCommentThread.event;
        this._onDidChangeCommentingEnabled = this._register(( new Emitter()));
        this.onDidChangeCommentingEnabled = this._onDidChangeCommentingEnabled.event;
        this._onDidChangeActiveCommentingRange = this._register(( new Emitter()));
        this.onDidChangeActiveCommentingRange = this._onDidChangeActiveCommentingRange.event;
        this._commentControls = ( new Map());
        this._commentMenus = ( new Map());
        this._isCommentingEnabled = true;
        this._continueOnComments = ( new Map());
        this._continueOnCommentProviders = ( new Set());
        this._commentsModel = this._register(( new CommentsModel()));
        this.commentsModel = this._commentsModel;
        this._handleConfiguration();
        this._handleZenMode();
        this._workspaceHasCommenting = CommentContextKeys.WorkspaceHasCommenting.bindTo(contextKeyService);
        const storageListener = this._register(( new DisposableStore()));
        const storageEvent = Event.debounce(this.storageService.onDidChangeValue(1 , CONTINUE_ON_COMMENTS, storageListener), (last, event) => last?.external ? last : event, 500);
        storageListener.add(storageEvent(v => {
            if (!v.external) {
                return;
            }
            const commentsToRestore = this.storageService.getObject(CONTINUE_ON_COMMENTS, 1 );
            if (!commentsToRestore) {
                return;
            }
            this.logService.debug(`Comments: URIs of continue on comments from storage ${( commentsToRestore.map(thread => ( thread.uri.toString()))).join(', ')}.`);
            const changedOwners = this._addContinueOnComments(commentsToRestore, this._continueOnComments);
            for (const owner of changedOwners) {
                const control = this._commentControls.get(owner);
                if (!control) {
                    continue;
                }
                const evt = {
                    owner,
                    ownerLabel: control.label,
                    pending: this._continueOnComments.get(owner) || [],
                    added: [],
                    removed: [],
                    changed: []
                };
                this.updateModelThreads(evt);
            }
        }));
        this._register(storageService.onWillSaveState(() => {
            const map = ( new Map());
            for (const provider of this._continueOnCommentProviders) {
                const pendingComments = provider.provideContinueOnComments();
                this._addContinueOnComments(pendingComments, map);
            }
            this._saveContinueOnComments(map);
        }));
    }
    _handleConfiguration() {
        this._isCommentingEnabled = this._defaultCommentingEnablement;
        this._register(this.configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('comments.visible')) {
                this.enableCommenting(this._defaultCommentingEnablement);
            }
        }));
    }
    _handleZenMode() {
        let preZenModeValue = this._isCommentingEnabled;
        this._register(this.layoutService.onDidChangeZenMode(e => {
            if (e) {
                preZenModeValue = this._isCommentingEnabled;
                this.enableCommenting(false);
            }
            else {
                this.enableCommenting(preZenModeValue);
            }
        }));
    }
    get _defaultCommentingEnablement() {
        return !!this.configurationService.getValue(COMMENTS_SECTION)?.visible;
    }
    get isCommentingEnabled() {
        return this._isCommentingEnabled;
    }
    enableCommenting(enable) {
        if (enable !== this._isCommentingEnabled) {
            this._isCommentingEnabled = enable;
            this._onDidChangeCommentingEnabled.fire(enable);
        }
    }
    setCurrentCommentThread(commentThread) {
        this._onDidChangeCurrentCommentThread.fire(commentThread);
    }
    setActiveEditingCommentThread(commentThread) {
        this._onDidChangeActiveEditingCommentThread.fire(commentThread);
    }
    async setActiveCommentAndThread(owner, commentInfo) {
        const commentController = this._commentControls.get(owner);
        if (!commentController) {
            return;
        }
        if (commentController !== this._lastActiveCommentController) {
            await this._lastActiveCommentController?.setActiveCommentAndThread(undefined);
        }
        this._lastActiveCommentController = commentController;
        return commentController.setActiveCommentAndThread(commentInfo);
    }
    setDocumentComments(resource, commentInfos) {
        this._onDidSetResourceCommentInfos.fire({ resource, commentInfos });
    }
    setModelThreads(ownerId, ownerLabel, commentThreads) {
        this._commentsModel.setCommentThreads(ownerId, ownerLabel, commentThreads);
        this._onDidSetAllCommentThreads.fire({ ownerId, ownerLabel, commentThreads });
    }
    updateModelThreads(event) {
        this._commentsModel.updateCommentThreads(event);
        this._onDidUpdateCommentThreads.fire(event);
    }
    setWorkspaceComments(owner, commentsByResource) {
        if (commentsByResource.length) {
            this._workspaceHasCommenting.set(true);
        }
        const control = this._commentControls.get(owner);
        if (control) {
            this.setModelThreads(owner, control.label, commentsByResource);
        }
    }
    removeWorkspaceComments(owner) {
        const control = this._commentControls.get(owner);
        if (control) {
            this.setModelThreads(owner, control.label, []);
        }
    }
    registerCommentController(owner, commentControl) {
        this._commentControls.set(owner, commentControl);
        this._onDidSetDataProvider.fire();
    }
    unregisterCommentController(owner) {
        if (owner) {
            this._commentControls.delete(owner);
        }
        else {
            this._commentControls.clear();
        }
        this._commentsModel.deleteCommentsByOwner(owner);
        this._onDidDeleteDataProvider.fire(owner);
    }
    getCommentController(owner) {
        return this._commentControls.get(owner);
    }
    async createCommentThreadTemplate(owner, resource, range) {
        const commentController = this._commentControls.get(owner);
        if (!commentController) {
            return;
        }
        return commentController.createCommentThreadTemplate(resource, range);
    }
    async updateCommentThreadTemplate(owner, threadHandle, range) {
        const commentController = this._commentControls.get(owner);
        if (!commentController) {
            return;
        }
        await commentController.updateCommentThreadTemplate(threadHandle, range);
    }
    disposeCommentThread(owner, threadId) {
        const controller = this.getCommentController(owner);
        controller?.deleteCommentThreadMain(threadId);
    }
    getCommentMenus(owner) {
        if (this._commentMenus.get(owner)) {
            return this._commentMenus.get(owner);
        }
        const menu = this.instantiationService.createInstance(CommentMenus);
        this._commentMenus.set(owner, menu);
        return menu;
    }
    updateComments(ownerId, event) {
        const control = this._commentControls.get(ownerId);
        if (control) {
            const evt = Object.assign({}, event, { owner: ownerId, ownerLabel: control.label });
            this.updateModelThreads(evt);
        }
    }
    updateNotebookComments(ownerId, event) {
        const evt = Object.assign({}, event, { owner: ownerId });
        this._onDidUpdateNotebookCommentThreads.fire(evt);
    }
    updateCommentingRanges(ownerId) {
        this._workspaceHasCommenting.set(true);
        this._onDidUpdateCommentingRanges.fire({ owner: ownerId });
    }
    async toggleReaction(owner, resource, thread, comment, reaction) {
        const commentController = this._commentControls.get(owner);
        if (commentController) {
            return commentController.toggleReaction(resource, thread, comment, reaction, CancellationToken.None);
        }
        else {
            throw new Error('Not supported');
        }
    }
    hasReactionHandler(owner) {
        const commentProvider = this._commentControls.get(owner);
        if (commentProvider) {
            return !!commentProvider.features.reactionHandler;
        }
        return false;
    }
    async getDocumentComments(resource) {
        const commentControlResult = [];
        for (const control of ( this._commentControls.values())) {
            commentControlResult.push(control.getDocumentComments(resource, CancellationToken.None)
                .then(documentComments => {
                for (const documentCommentThread of documentComments.threads) {
                    if (documentCommentThread.comments?.length === 0 && documentCommentThread.range) {
                        this.removeContinueOnComment({ range: documentCommentThread.range, uri: resource, owner: documentComments.owner });
                    }
                }
                const pendingComments = this._continueOnComments.get(documentComments.owner);
                documentComments.pendingCommentThreads = pendingComments?.filter(pendingComment => ( pendingComment.uri.toString()) === ( resource.toString()));
                return documentComments;
            })
                .catch(_ => {
                return null;
            }));
        }
        return Promise.all(commentControlResult);
    }
    async getNotebookComments(resource) {
        const commentControlResult = [];
        this._commentControls.forEach(control => {
            commentControlResult.push(control.getNotebookComments(resource, CancellationToken.None)
                .catch(_ => {
                return null;
            }));
        });
        return Promise.all(commentControlResult);
    }
    registerContinueOnCommentProvider(provider) {
        this._continueOnCommentProviders.add(provider);
        return {
            dispose: () => {
                this._continueOnCommentProviders.delete(provider);
            }
        };
    }
    _saveContinueOnComments(map) {
        const commentsToSave = [];
        for (const pendingComments of ( map.values())) {
            commentsToSave.push(...pendingComments);
        }
        this.logService.debug(`Comments: URIs of continue on comments to add to storage ${( commentsToSave.map(thread => ( thread.uri.toString()))).join(', ')}.`);
        this.storageService.store(CONTINUE_ON_COMMENTS, commentsToSave, 1 , 0 );
    }
    removeContinueOnComment(pendingComment) {
        const pendingComments = this._continueOnComments.get(pendingComment.owner);
        if (pendingComments) {
            const commentIndex = pendingComments.findIndex(comment => ( comment.uri.toString()) === ( pendingComment.uri.toString()) && Range.equalsRange(comment.range, pendingComment.range) && (pendingComment.isReply === undefined || comment.isReply === pendingComment.isReply));
            if (commentIndex > -1) {
                return pendingComments.splice(commentIndex, 1)[0];
            }
        }
        return undefined;
    }
    _addContinueOnComments(pendingComments, map) {
        const changedOwners = ( new Set());
        for (const pendingComment of pendingComments) {
            if (!( map.has(pendingComment.owner))) {
                map.set(pendingComment.owner, [pendingComment]);
                changedOwners.add(pendingComment.owner);
            }
            else {
                const commentsForOwner = map.get(pendingComment.owner);
                if (commentsForOwner.every(comment => (( comment.uri.toString()) !== ( pendingComment.uri.toString())) || !Range.equalsRange(comment.range, pendingComment.range))) {
                    commentsForOwner.push(pendingComment);
                    changedOwners.add(pendingComment.owner);
                }
            }
        }
        return changedOwners;
    }
};
CommentService = ( __decorate([
    ( __param(0, IInstantiationService)),
    ( __param(1, IWorkbenchLayoutService)),
    ( __param(2, IConfigurationService)),
    ( __param(3, IContextKeyService)),
    ( __param(4, IStorageService)),
    ( __param(5, ILogService))
], CommentService));
export { CommentService, ICommentService };
