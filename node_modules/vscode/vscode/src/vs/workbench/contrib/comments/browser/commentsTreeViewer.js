import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { append, $ } from '../../../../base/browser/dom.js';
import { localize2WithPath, localizeWithPath } from '../../../../nls.js';
import { renderMarkdown } from '../../../../base/browser/markdownRenderer.js';
import { DisposableStore } from '../../../../base/common/lifecycle.js';
import { IOpenerService } from '../../../../platform/opener/common/opener.js';
import { ResourceWithCommentThreads, CommentNode } from '../common/commentModel.js';
import { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';
import { WorkbenchObjectTree, IListService } from '../../../../platform/list/browser/listService.js';
import { IThemeService } from '../../../../platform/theme/common/themeService.js';
import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
import { TimestampWidget } from './timestamp.js';
import { Codicon } from '../../../../base/common/codicons.js';
import { ThemeIcon } from '../../../../base/common/themables.js';
import { commentViewThreadStateColorVar, getCommentThreadStateIconColor } from './commentColors.js';
import { CommentThreadState } from '../../../../editor/common/languages.js';
import { FilterOptions } from './commentsFilterOptions.js';
import { basename } from '../../../../base/common/resources.js';
import { openLinkFromMarkdown } from '../../../../editor/browser/widget/markdownRenderer/browser/markdownRenderer.js';
import { CommentsModel } from './commentsModel.js';
const COMMENTS_VIEW_ID = 'workbench.panel.comments';
const COMMENTS_VIEW_STORAGE_ID = 'Comments';
const COMMENTS_VIEW_TITLE = ( localize2WithPath(
    'vs/workbench/contrib/comments/browser/commentsTreeViewer',
    'comments.view.title',
    "Comments"
));
class CommentsModelVirualDelegate {
    static { this.RESOURCE_ID = 'resource-with-comments'; }
    static { this.COMMENT_ID = 'comment-node'; }
    getHeight(element) {
        if ((element instanceof CommentNode) && element.hasReply()) {
            return 44;
        }
        return 22;
    }
    getTemplateId(element) {
        if (element instanceof ResourceWithCommentThreads) {
            return CommentsModelVirualDelegate.RESOURCE_ID;
        }
        if (element instanceof CommentNode) {
            return CommentsModelVirualDelegate.COMMENT_ID;
        }
        return '';
    }
}
class ResourceWithCommentsRenderer {
    constructor(labels) {
        this.labels = labels;
        this.templateId = 'resource-with-comments';
    }
    renderTemplate(container) {
        const labelContainer = append(container, $('.resource-container'));
        const resourceLabel = this.labels.create(labelContainer);
        const separator = append(labelContainer, $('.separator'));
        const owner = labelContainer.appendChild($('.owner'));
        return { resourceLabel, owner, separator };
    }
    renderElement(node, index, templateData, height) {
        templateData.resourceLabel.setFile(node.element.resource);
        templateData.separator.innerText = '\u00b7';
        if (node.element.ownerLabel) {
            templateData.owner.innerText = node.element.ownerLabel;
            templateData.separator.style.display = 'inline';
        }
        else {
            templateData.owner.innerText = '';
            templateData.separator.style.display = 'none';
        }
    }
    disposeTemplate(templateData) {
        templateData.resourceLabel.dispose();
    }
}
let CommentNodeRenderer = class CommentNodeRenderer {
    constructor(openerService, configurationService, themeService) {
        this.openerService = openerService;
        this.configurationService = configurationService;
        this.themeService = themeService;
        this.templateId = 'comment-node';
    }
    renderTemplate(container) {
        const threadContainer = append(container, $('.comment-thread-container'));
        const metadataContainer = append(threadContainer, $('.comment-metadata-container'));
        const threadMetadata = {
            icon: append(metadataContainer, $('.icon')),
            userNames: append(metadataContainer, $('.user')),
            timestamp: ( new TimestampWidget(
                this.configurationService,
                append(metadataContainer, $('.timestamp-container'))
            )),
            separator: append(metadataContainer, $('.separator')),
            commentPreview: append(metadataContainer, $('.text')),
            range: append(metadataContainer, $('.range'))
        };
        threadMetadata.separator.innerText = '\u00b7';
        const snippetContainer = append(threadContainer, $('.comment-snippet-container'));
        const repliesMetadata = {
            container: snippetContainer,
            icon: append(snippetContainer, $('.icon')),
            count: append(snippetContainer, $('.count')),
            lastReplyDetail: append(snippetContainer, $('.reply-detail')),
            separator: append(snippetContainer, $('.separator')),
            timestamp: ( new TimestampWidget(
                this.configurationService,
                append(snippetContainer, $('.timestamp-container'))
            )),
        };
        repliesMetadata.separator.innerText = '\u00b7';
        repliesMetadata.icon.classList.add(...ThemeIcon.asClassNameArray(Codicon.indent));
        const disposables = [threadMetadata.timestamp, repliesMetadata.timestamp];
        return { threadMetadata, repliesMetadata, disposables };
    }
    getCountString(commentCount) {
        if (commentCount > 1) {
            return ( localizeWithPath(
                'vs/workbench/contrib/comments/browser/commentsTreeViewer',
                'commentsCount',
                "{0} comments",
                commentCount
            ));
        }
        else {
            return ( localizeWithPath(
                'vs/workbench/contrib/comments/browser/commentsTreeViewer',
                'commentCount',
                "1 comment"
            ));
        }
    }
    getRenderedComment(commentBody, disposables) {
        const renderedComment = renderMarkdown(commentBody, {
            inline: true,
            actionHandler: {
                callback: (link) => openLinkFromMarkdown(this.openerService, link, commentBody.isTrusted),
                disposables: disposables
            }
        });
        const images = renderedComment.element.getElementsByTagName('img');
        for (let i = 0; i < images.length; i++) {
            const image = images[i];
            const textDescription = $('');
            textDescription.textContent = image.alt ? ( localizeWithPath(
                'vs/workbench/contrib/comments/browser/commentsTreeViewer',
                'imageWithLabel',
                "Image: {0}",
                image.alt
            )) : ( localizeWithPath(
                'vs/workbench/contrib/comments/browser/commentsTreeViewer',
                'image',
                "Image"
            ));
            image.parentNode.replaceChild(textDescription, image);
        }
        return renderedComment;
    }
    getIcon(threadState) {
        if (threadState === CommentThreadState.Unresolved) {
            return Codicon.commentUnresolved;
        }
        else {
            return Codicon.comment;
        }
    }
    renderElement(node, index, templateData, height) {
        const commentCount = node.element.replies.length + 1;
        templateData.threadMetadata.icon.classList.remove(...Array.from(( templateData.threadMetadata.icon.classList.values()))
            .filter(value => value.startsWith('codicon')));
        templateData.threadMetadata.icon.classList.add(...ThemeIcon.asClassNameArray(this.getIcon(node.element.threadState)));
        if (node.element.threadState !== undefined) {
            const color = this.getCommentThreadWidgetStateColor(node.element.threadState, this.themeService.getColorTheme());
            templateData.threadMetadata.icon.style.setProperty(commentViewThreadStateColorVar, `${color}`);
            templateData.threadMetadata.icon.style.color = `var(${commentViewThreadStateColorVar})`;
        }
        templateData.threadMetadata.userNames.textContent = node.element.comment.userName;
        templateData.threadMetadata.timestamp.setTimestamp(node.element.comment.timestamp ? ( new Date(node.element.comment.timestamp)) : undefined);
        const originalComment = node.element;
        templateData.threadMetadata.commentPreview.innerText = '';
        templateData.threadMetadata.commentPreview.style.height = '22px';
        if (typeof originalComment.comment.body === 'string') {
            templateData.threadMetadata.commentPreview.innerText = originalComment.comment.body;
        }
        else {
            const disposables = ( new DisposableStore());
            templateData.disposables.push(disposables);
            const renderedComment = this.getRenderedComment(originalComment.comment.body, disposables);
            templateData.disposables.push(renderedComment);
            templateData.threadMetadata.commentPreview.appendChild(renderedComment.element.firstElementChild ?? renderedComment.element);
            templateData.threadMetadata.commentPreview.title = renderedComment.element.textContent ?? '';
        }
        if (node.element.range) {
            if (node.element.range.startLineNumber === node.element.range.endLineNumber) {
                templateData.threadMetadata.range.textContent = ( localizeWithPath(
                    'vs/workbench/contrib/comments/browser/commentsTreeViewer',
                    'commentLine',
                    "[Ln {0}]",
                    node.element.range.startLineNumber
                ));
            }
            else {
                templateData.threadMetadata.range.textContent = ( localizeWithPath(
                    'vs/workbench/contrib/comments/browser/commentsTreeViewer',
                    'commentRange',
                    "[Ln {0}-{1}]",
                    node.element.range.startLineNumber,
                    node.element.range.endLineNumber
                ));
            }
        }
        if (!node.element.hasReply()) {
            templateData.repliesMetadata.container.style.display = 'none';
            return;
        }
        templateData.repliesMetadata.container.style.display = '';
        templateData.repliesMetadata.count.textContent = this.getCountString(commentCount);
        const lastComment = node.element.replies[node.element.replies.length - 1].comment;
        templateData.repliesMetadata.lastReplyDetail.textContent = ( localizeWithPath(
            'vs/workbench/contrib/comments/browser/commentsTreeViewer',
            'lastReplyFrom',
            "Last reply from {0}",
            lastComment.userName
        ));
        templateData.repliesMetadata.timestamp.setTimestamp(lastComment.timestamp ? ( new Date(lastComment.timestamp)) : undefined);
    }
    getCommentThreadWidgetStateColor(state, theme) {
        return (state !== undefined) ? getCommentThreadStateIconColor(state, theme) : undefined;
    }
    disposeTemplate(templateData) {
        templateData.disposables.forEach(disposeable => disposeable.dispose());
    }
};
CommentNodeRenderer = ( __decorate([
    ( __param(0, IOpenerService)),
    ( __param(1, IConfigurationService)),
    ( __param(2, IThemeService))
], CommentNodeRenderer));
class Filter {
    constructor(options) {
        this.options = options;
    }
    filter(element, parentVisibility) {
        if (this.options.filter === '' && this.options.showResolved && this.options.showUnresolved) {
            return 1 ;
        }
        if (element instanceof ResourceWithCommentThreads) {
            return this.filterResourceMarkers(element);
        }
        else {
            return this.filterCommentNode(element, parentVisibility);
        }
    }
    filterResourceMarkers(resourceMarkers) {
        if (this.options.textFilter.text && !this.options.textFilter.negate) {
            const uriMatches = FilterOptions._filter(this.options.textFilter.text, basename(resourceMarkers.resource));
            if (uriMatches) {
                return { visibility: true, data: { type: 0 , uriMatches: uriMatches || [] } };
            }
        }
        return 2 ;
    }
    filterCommentNode(comment, parentVisibility) {
        const matchesResolvedState = (comment.threadState === undefined) || (this.options.showResolved && CommentThreadState.Resolved === comment.threadState) ||
            (this.options.showUnresolved && CommentThreadState.Unresolved === comment.threadState);
        if (!matchesResolvedState) {
            return false;
        }
        if (!this.options.textFilter.text) {
            return true;
        }
        const textMatches =
        FilterOptions._messageFilter(this.options.textFilter.text, typeof comment.comment.body === 'string' ? comment.comment.body : comment.comment.body.value)
            || FilterOptions._messageFilter(this.options.textFilter.text, comment.comment.userName)
            || ( comment.replies.map(reply => {
                return FilterOptions._messageFilter(this.options.textFilter.text, reply.comment.userName)
                    || FilterOptions._messageFilter(this.options.textFilter.text, typeof reply.comment.body === 'string' ? reply.comment.body : reply.comment.body.value);
            })).filter(value => !!value).flat();
        if (textMatches.length && !this.options.textFilter.negate) {
            return { visibility: true, data: { type: 1 , textMatches } };
        }
        if (textMatches.length && this.options.textFilter.negate && parentVisibility === 2 ) {
            return false;
        }
        if ((textMatches.length === 0) && this.options.textFilter.negate && parentVisibility === 2 ) {
            return true;
        }
        return parentVisibility;
    }
}
let CommentsList = class CommentsList extends WorkbenchObjectTree {
    constructor(labels, container, options, contextKeyService, listService, instantiationService, configurationService) {
        const delegate = ( new CommentsModelVirualDelegate());
        const renderers = [
            instantiationService.createInstance(ResourceWithCommentsRenderer, labels),
            instantiationService.createInstance(CommentNodeRenderer)
        ];
        super('CommentsTree', container, delegate, renderers, {
            accessibilityProvider: options.accessibilityProvider,
            identityProvider: {
                getId: (element) => {
                    if (element instanceof CommentsModel) {
                        return 'root';
                    }
                    if (element instanceof ResourceWithCommentThreads) {
                        return `${element.owner}-${element.id}`;
                    }
                    if (element instanceof CommentNode) {
                        return `${element.owner}-${( element.resource.toString())}-${element.threadId}-${element.comment.uniqueIdInThread}` + (element.isRoot ? '-root' : '');
                    }
                    return '';
                }
            },
            expandOnlyOnTwistieClick: true,
            collapseByDefault: false,
            overrideStyles: options.overrideStyles,
            filter: options.filter,
            findWidgetEnabled: false
        }, instantiationService, contextKeyService, listService, configurationService);
    }
    filterComments() {
        this.refilter();
    }
    getVisibleItemCount() {
        let filtered = 0;
        const root = this.getNode();
        for (const resourceNode of root.children) {
            for (const commentNode of resourceNode.children) {
                if (commentNode.visible && resourceNode.visible) {
                    filtered++;
                }
            }
        }
        return filtered;
    }
};
CommentsList = ( __decorate([
    ( __param(3, IContextKeyService)),
    ( __param(4, IListService)),
    ( __param(5, IInstantiationService)),
    ( __param(6, IConfigurationService))
], CommentsList));
export { COMMENTS_VIEW_ID, COMMENTS_VIEW_STORAGE_ID, COMMENTS_VIEW_TITLE, CommentNodeRenderer, CommentsList, Filter, ResourceWithCommentsRenderer };
