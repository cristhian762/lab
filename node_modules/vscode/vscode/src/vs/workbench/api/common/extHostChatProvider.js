import { CancellationTokenSource } from '../../../base/common/cancellation.js';
import { toDisposable } from '../../../base/common/lifecycle.js';
import { MainContext } from './extHost.protocol.js';
import { LanguageModelMessage } from './extHostTypeConverters.js';
import { Progress } from '../../../platform/progress/common/progress.js';
import { ExtensionIdentifierMap, ExtensionIdentifier, ExtensionIdentifierSet } from '../../../platform/extensions/common/extensions.js';
import { AsyncIterableSource } from '../../../base/common/async.js';
import { Emitter, Event } from '../../../base/common/event.js';
import { localizeWithPath } from '../../../nls.js';
import { INTERNAL_AUTH_PROVIDER_PREFIX } from '../../services/authentication/common/authentication.js';
import { toErrorMessage } from '../../../base/common/errorMessage.js';
class LanguageModelResponseStream {
    constructor(option, stream) {
        this.option = option;
        this.stream = ( new AsyncIterableSource());
        this.stream = stream ?? ( new AsyncIterableSource());
    }
}
class LanguageModelRequest {
    constructor(promise, cts) {
        this.cts = cts;
        this._responseStreams = ( new Map());
        this._defaultStream = ( new AsyncIterableSource());
        this._isDone = false;
        const that = this;
        this.apiObject = {
            result: promise,
            stream: that._defaultStream.asyncIterable,
        };
        promise.then(() => {
            for (const stream of this._streams()) {
                stream.resolve();
            }
        }).catch(err => {
            if (!(err instanceof Error)) {
                err = ( new Error(toErrorMessage(err), { cause: err }));
            }
            for (const stream of this._streams()) {
                stream.reject(err);
            }
        }).finally(() => {
            this._isDone = true;
        });
    }
    *_streams() {
        if (this._responseStreams.size > 0) {
            for (const [, value] of this._responseStreams) {
                yield value.stream;
            }
        }
        else {
            yield this._defaultStream;
        }
    }
    handleFragment(fragment) {
        if (this._isDone) {
            return;
        }
        let res = this._responseStreams.get(fragment.index);
        if (!res) {
            if (this._responseStreams.size === 0) {
                res = ( new LanguageModelResponseStream(fragment.index, this._defaultStream));
            }
            else {
                res = ( new LanguageModelResponseStream(fragment.index));
            }
            this._responseStreams.set(fragment.index, res);
        }
        res.stream.emitOne(fragment.part);
    }
}
class ExtHostChatProvider {
    static { this._idPool = 1; }
    constructor(mainContext, _logService, _extHostAuthentication) {
        this._logService = _logService;
        this._extHostAuthentication = _extHostAuthentication;
        this._onDidChangeModelAccess = ( new Emitter());
        this._onDidChangeProviders = ( new Emitter());
        this.onDidChangeProviders = this._onDidChangeProviders.event;
        this._languageModels = ( new Map());
        this._languageModelIds = ( new Set());
        this._modelAccessList = ( new ExtensionIdentifierMap());
        this._pendingRequest = ( new Map());
        this._proxy = ( mainContext.getProxy(MainContext.MainThreadChatProvider));
    }
    dispose() {
        this._onDidChangeModelAccess.dispose();
        this._onDidChangeProviders.dispose();
    }
    registerLanguageModel(extension, identifier, provider, metadata) {
        const handle = ExtHostChatProvider._idPool++;
        this._languageModels.set(handle, { extension: extension.identifier, provider });
        let auth;
        if (metadata.auth) {
            auth = {
                providerLabel: extension.displayName || extension.name,
                accountLabel: typeof metadata.auth === 'object' ? metadata.auth.label : undefined
            };
        }
        this._proxy.$registerProvider(handle, identifier, {
            extension: extension.identifier,
            model: metadata.name ?? '',
            auth
        });
        return toDisposable(() => {
            this._languageModels.delete(handle);
            this._proxy.$unregisterProvider(handle);
        });
    }
    async $provideLanguageModelResponse(handle, requestId, from, messages, options, token) {
        const data = this._languageModels.get(handle);
        if (!data) {
            return;
        }
        const progress = ( new Progress(async (fragment) => {
            if (token.isCancellationRequested) {
                this._logService.warn(`[CHAT](${data.extension.value}) CANNOT send progress because the REQUEST IS CANCELLED`);
                return;
            }
            this._proxy.$handleProgressChunk(requestId, { index: fragment.index, part: fragment.part });
        }));
        return data.provider.provideLanguageModelResponse2(( messages.map(LanguageModelMessage.to)), options, ExtensionIdentifier.toKey(from), progress, token);
    }
    $updateLanguageModels(data) {
        const added = [];
        const removed = [];
        if (data.added) {
            for (const id of data.added) {
                this._languageModelIds.add(id);
                added.push(id);
            }
        }
        if (data.removed) {
            for (const id of data.removed) {
                this._languageModelIds.delete(id);
                removed.push(id);
                for (const [key, value] of this._pendingRequest) {
                    if (value.languageModelId === id) {
                        value.res.cts.cancel();
                        this._pendingRequest.delete(key);
                    }
                }
            }
        }
        this._onDidChangeProviders.fire(( Object.freeze({
            added: ( Object.freeze(added)),
            removed: ( Object.freeze(removed))
        })));
    }
    getLanguageModelIds() {
        return Array.from(this._languageModelIds);
    }
    $updateModelAccesslist(data) {
        const updated = ( new Array());
        for (const { from, to, enabled } of data) {
            const set = this._modelAccessList.get(from) ?? ( new ExtensionIdentifierSet());
            const oldValue = ( set.has(to));
            if (oldValue !== enabled) {
                if (enabled) {
                    set.add(to);
                }
                else {
                    set.delete(to);
                }
                this._modelAccessList.set(from, set);
                const newItem = { from, to };
                updated.push(newItem);
                this._onDidChangeModelAccess.fire(newItem);
            }
        }
    }
    async requestLanguageModelAccess(extension, languageModelId, options) {
        const from = extension.identifier;
        const justification = options?.justification;
        const metadata = await this._proxy.$prepareChatAccess(from, languageModelId, justification);
        if (!metadata) {
            throw new Error(`Language model '${languageModelId}' NOT found`);
        }
        if (this._isUsingAuth(from, metadata)) {
            await this._getAuthAccess(extension, { identifier: metadata.extension, displayName: metadata.auth.providerLabel }, justification);
        }
        const that = this;
        return {
            get model() {
                return metadata.model;
            },
            get isRevoked() {
                return (that._isUsingAuth(from, metadata) && !that._modelAccessList.get(from)?.has(metadata.extension)) || !( that._languageModelIds.has(languageModelId));
            },
            get onDidChangeAccess() {
                const onDidRemoveLM = Event.filter(that._onDidChangeProviders.event, e => e.removed.includes(languageModelId));
                const onDidChangeModelAccess = Event.filter(that._onDidChangeModelAccess.event, e => ExtensionIdentifier.equals(e.from, from) && ExtensionIdentifier.equals(e.to, metadata.extension));
                return Event.signal(Event.any(onDidRemoveLM, onDidChangeModelAccess));
            },
            makeChatRequest(messages, options, token) {
                if (that._isUsingAuth(from, metadata) && !that._modelAccessList.get(from)?.has(metadata.extension)) {
                    throw new Error('Access to chat has been revoked');
                }
                if (!( that._languageModelIds.has(languageModelId))) {
                    throw new Error('Language Model has been removed');
                }
                const cts = ( new CancellationTokenSource(token));
                const requestId = (Math.random() * 1e6) | 0;
                const requestPromise = that._proxy.$fetchResponse(from, languageModelId, requestId, ( messages.map(LanguageModelMessage.from)), options ?? {}, cts.token);
                const res = ( new LanguageModelRequest(requestPromise, cts));
                that._pendingRequest.set(requestId, { languageModelId, res });
                requestPromise.finally(() => {
                    that._pendingRequest.delete(requestId);
                    cts.dispose();
                });
                return res.apiObject;
            },
        };
    }
    async $handleResponseFragment(requestId, chunk) {
        const data = this._pendingRequest.get(requestId);
        if (data) {
            data.res.handleFragment(chunk);
        }
    }
    async _getAuthAccess(from, to, justification) {
        const providerId = INTERNAL_AUTH_PROVIDER_PREFIX + to.identifier.value;
        const session = await this._extHostAuthentication.getSession(from, providerId, [], { silent: true });
        if (!session) {
            try {
                const detail = justification
                    ? ( localizeWithPath(
                    'vs/workbench/api/common/extHostChatProvider',
                    'chatAccessWithJustification',
                    "To allow access to the language models provided by {0}. Justification:\n\n{1}",
                    to.displayName,
                    justification
                ))
                    : ( localizeWithPath(
                    'vs/workbench/api/common/extHostChatProvider',
                    'chatAccess',
                    "To allow access to the language models provided by {0}",
                    to.displayName
                ));
                await this._extHostAuthentication.getSession(from, providerId, [], { forceNewSession: { detail } });
            }
            catch (err) {
                throw new Error('Access to language models has not been granted');
            }
        }
        this.$updateModelAccesslist([{ from: from.identifier, to: to.identifier, enabled: true }]);
    }
    _isUsingAuth(from, toMetadata) {
        return !!toMetadata.auth
            && !ExtensionIdentifier.equals(toMetadata.extension, from);
    }
}
export { ExtHostChatProvider };
